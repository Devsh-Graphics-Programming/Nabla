// Copyright (C) 2002-2012 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine".
// For conditions of distribution and use, see copyright notice in irrlicht.h

#ifndef __I_MESH_BUFFER_H_INCLUDED__
#define __I_MESH_BUFFER_H_INCLUDED__

#include "ITransformFeedback.h"
#include "SMaterial.h"
#include "aabbox3d.h"
#include "SVertexIndex.h"
#include "EPrimitiveTypes.h"
#include "ICPUBuffer.h"
#include "IGPUBuffer.h"
#include "SMaterial.h"
#include "vectorSIMD.h"
#include "coreutil.h"
//#include "os.h"

namespace irr
{
namespace scene
{

    enum E_VERTEX_ATTRIBUTE_ID
    {
        EVAI_ATTR0=0,
        EVAI_ATTR1,
        EVAI_ATTR2,
        EVAI_ATTR3,
        EVAI_ATTR4,
        EVAI_ATTR5,
        EVAI_ATTR6,
        EVAI_ATTR7,
        EVAI_ATTR8,
        EVAI_ATTR9,
        EVAI_ATTR10,
        EVAI_ATTR11,
        EVAI_ATTR12,
        EVAI_ATTR13,
        EVAI_ATTR14,
        EVAI_ATTR15,
        EVAI_COUNT
    };

    enum E_COMPONENTS_PER_ATTRIBUTE
    {
        ECPA_REVERSED_OR_BGRA=0,
        ECPA_ONE,
        ECPA_TWO,
        ECPA_THREE,
        ECPA_FOUR,
        ECPA_COUNT
    };

    enum E_COMPONENT_TYPE
    {
        ECT_FLOAT=0,
        ECT_HALF_FLOAT,
        ECT_DOUBLE_IN_FLOAT_OUT,
        ECT_UNSIGNED_INT_10F_11F_11F_REV,
        //INTEGER FORMS
        ECT_NORMALIZED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_BYTE,
        ECT_NORMALIZED_UNSIGNED_BYTE,
        ECT_NORMALIZED_SHORT,
        ECT_NORMALIZED_UNSIGNED_SHORT,
        ECT_NORMALIZED_INT,
        ECT_NORMALIZED_UNSIGNED_INT,
        ECT_INT_2_10_10_10_REV,
        ECT_UNSIGNED_INT_2_10_10_10_REV,
        ECT_BYTE,
        ECT_UNSIGNED_BYTE,
        ECT_SHORT,
        ECT_UNSIGNED_SHORT,
        ECT_INT,
        ECT_UNSIGNED_INT,
        ECT_INTEGER_INT_2_10_10_10_REV,
        ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV,
        ECT_INTEGER_BYTE,
        ECT_INTEGER_UNSIGNED_BYTE,
        ECT_INTEGER_SHORT,
        ECT_INTEGER_UNSIGNED_SHORT,
        ECT_INTEGER_INT,
        ECT_INTEGER_UNSIGNED_INT,
        //special
        ECT_DOUBLE_IN_DOUBLE_OUT, //only accepted by glVertexAttribLPointer
        ECT_COUNT
    };
/**
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.

GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.

GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.

GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
**/
    static size_t vertexAttrSize[ECT_COUNT][ECPA_COUNT] = {
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,8,16,24,32},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4,0xdeadbeefu}, //ECT_UNSIGNED_INT_10F_11F_11F_REV
        //integers
        //normalized
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_INT_2_10_10_10_REV
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, //ECT_NORMALIZED_BYTE
        {4,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //un normalized ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //native ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //special
        {0xdeadbeefu,8,16,24,32}
    };

    inline bool validCombination(const E_COMPONENT_TYPE& type, const E_COMPONENTS_PER_ATTRIBUTE& components)
    {
        return vertexAttrSize[type][components]<0xdeadbeefu;
    }

    inline bool isNormalized(const E_COMPONENT_TYPE& type)
    {
        return type>=ECT_NORMALIZED_INT_2_10_10_10_REV&&type<=ECT_NORMALIZED_UNSIGNED_INT;
    }



	template <class T>
	class IMeshDataFormatDesc : public virtual IReferenceCounted
	{
    protected:
	    //vertices
            E_COMPONENTS_PER_ATTRIBUTE compntsPerAttr[EVAI_COUNT];
            E_COMPONENT_TYPE attrType[EVAI_COUNT];
            size_t attrStride[EVAI_COUNT];
            size_t attrOffset[EVAI_COUNT];
            uint32_t attrDivisor[EVAI_COUNT];
	public:
	    IMeshDataFormatDesc()
	    {
            for (size_t i=0; i<EVAI_COUNT; i++)
            {
                compntsPerAttr[i] = ECPA_FOUR;
                attrType[i] = ECT_FLOAT;
                attrStride[i] = 16;
                attrOffset[i] = 0;
                attrDivisor[i] = 0;
            }
	    }

	    virtual bool formatCanBeAppended(const IMeshDataFormatDesc* other) const = 0;

		virtual void mapIndexBuffer(T* ixbuf) = 0;

		virtual const T* getIndexBuffer() const = 0;


        virtual void mapVertexAttrBuffer(T* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0) = 0;

        virtual const T* getMappedBuffer(const E_VERTEX_ATTRIBUTE_ID& attrId) const = 0;


        inline E_COMPONENT_TYPE getAttribType(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return ECT_COUNT;

            return attrType[attrId];
        }

        inline E_COMPONENTS_PER_ATTRIBUTE getAttribComponentCount(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return ECPA_COUNT;

            return compntsPerAttr[attrId];
        }

        virtual void setMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId, const size_t &offset) = 0;

        inline size_t getMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return 0;

            return attrOffset[attrId];
        }

        inline size_t getMappedBufferStride(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return 0;

            return attrStride[attrId];
        }

        inline uint32_t getAttribDivisor(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return 0;

            return attrDivisor[attrId];
        }

        inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId)
        {
            swapVertexAttrBuffer(attrBuf, attrId, attrOffset[attrId], attrStride[attrId]);
        }

        inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset)
        {
            swapVertexAttrBuffer(attrBuf, attrId, newOffset, attrStride[attrId]);
        }

        virtual void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset, const size_t& newStride) = 0;
	};


	class ICPUMeshDataFormatDesc : public IMeshDataFormatDesc<core::ICPUBuffer>
	{
        private:
            inline bool formatCanBeAppended(const ICPUMeshDataFormatDesc* other) const
            {
                bool retVal = true;
                for (size_t i=0; retVal&&i<EVAI_COUNT; i++)
                {
                    if (mappedAttrBuf[i])
                    {
                        if (reinterpret_cast<const ICPUMeshDataFormatDesc*>(other)->mappedAttrBuf[i])
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                        else
                            return false;
                    }
                    else
                    {
                        if (reinterpret_cast<const ICPUMeshDataFormatDesc*>(other)->mappedAttrBuf[i])
                            return false;
                        else
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                    }
                }
                return retVal;
            }
        protected:
            //vertices
            core::ICPUBuffer* mappedAttrBuf[EVAI_COUNT];
            //indices
            core::ICPUBuffer* mappedIndexBuf;
	    public:
	        ICPUMeshDataFormatDesc()
	        {
                for (size_t i=0; i<EVAI_COUNT; i++)
                    mappedAttrBuf[i] = NULL;

                mappedIndexBuf = NULL;
	        }
	        ~ICPUMeshDataFormatDesc()
	        {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    if (mappedAttrBuf[i])
                        mappedAttrBuf[i]->drop();
                }

                if (getIndexBuffer())
                    getIndexBuffer()->drop();
	        }

            bool formatCanBeAppended(const IMeshDataFormatDesc<core::ICPUBuffer>* other) const
            {
                return formatCanBeAppended(reinterpret_cast<const ICPUMeshDataFormatDesc*>(other));
            }

            void mapIndexBuffer(core::ICPUBuffer* ixbuf)
            {
        /*
        #ifdef _DEBUG
                if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
                {
                    os::Printer::log("MeshBuffer map index buffer overflow!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG
        */
                if (ixbuf)
                    ixbuf->grab();

                if (mappedIndexBuf)
                    mappedIndexBuf->drop();
                mappedIndexBuf = ixbuf;
            }

            virtual const core::ICPUBuffer* getIndexBuffer() const
            {
                return mappedIndexBuf;
            }

            void mapVertexAttrBuffer(core::ICPUBuffer* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0)
            {
                if (attrId>=EVAI_COUNT)
        #ifdef _DEBUG
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer attribute ID out of range!\n",ELL_ERROR);
                    return;
                }

                if (!validCombination(type,components))
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer INVALID COMBINATION OF COMPONENT TYPE AND COUNT!\n",ELL_ERROR);
                    return;
                }
        #else
                    return;
        #endif // _DEBUG

                if (attrBuf)
                {
                    attrBuf->grab();

                    compntsPerAttr[attrId] = components;
                    attrType[attrId] = type;
                    attrStride[attrId] = stride!=0 ? stride:vertexAttrSize[type][components];
                    attrOffset[attrId] = offset;
                    attrDivisor[attrId] = divisor;
                }
                else
                {
                    compntsPerAttr[attrId] = ECPA_FOUR;
                    attrType[attrId] = ECT_FLOAT;
                    attrStride[attrId] = 16;
                    attrOffset[attrId] = 0;
                    attrDivisor[attrId] = 0;
                }

                if (mappedAttrBuf[attrId])
                    mappedAttrBuf[attrId]->drop();
                mappedAttrBuf[attrId] = attrBuf;
            }

            virtual const core::ICPUBuffer* getMappedBuffer(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                if (attrId>=EVAI_COUNT)
                    return NULL;

                return mappedAttrBuf[attrId];
            }


            void setMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId, const size_t &offset)
            {
                if (attrId>=EVAI_COUNT)
        #ifdef _DEBUG
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer attribute ID out of range!\n",ELL_ERROR);
                    return;
                }
        #else
                    return;
        #endif // _DEBUG
                if (!mappedAttrBuf[attrId])
                    return;

                attrOffset[attrId] = offset;
            }

            void swapVertexAttrBuffer(core::ICPUBuffer* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset, const size_t& newStride)
            {
                if (!mappedAttrBuf[attrId] || !attrBuf)
                    return;

                attrBuf->grab();
                mappedAttrBuf[attrId]->drop();
                mappedAttrBuf[attrId] = attrBuf;
                attrOffset[attrId] = newOffset;
                attrStride[attrId] = newStride;
            }
	};

	typedef IMeshDataFormatDesc<video::IGPUBuffer> IGPUMeshDataFormatDesc;




	template <class T>
	class IMeshBuffer : public virtual IReferenceCounted
	{
    protected:
        video::SMaterial Material;
        core::aabbox3df boundingBox;
        IMeshDataFormatDesc<T>* meshLayout;
	    //indices
	    video::E_INDEX_TYPE indexType;
	    int32_t baseVertex;
        uint64_t indexCount;
        size_t indexBufOffset;
        //
        size_t instanceCount;
        uint32_t baseInstance;
        //primitives
        scene::E_PRIMITIVE_TYPE primitiveType;

        //debug
        core::LeakDebugger* leakDebugger;
	public:
	    IMeshBuffer(IMeshDataFormatDesc<T>* layout=NULL, core::LeakDebugger* dbgr=NULL) : leakDebugger(dbgr)
	    {
            if (leakDebugger)
                leakDebugger->registerObj(this);

	        meshLayout = layout;
	        if (meshLayout)
                meshLayout->grab();

            indexType = video::EIT_UNKNOWN;
            baseVertex = 0;
            indexCount = 0;
            indexBufOffset = 0;

	        primitiveType = scene::EPT_TRIANGLES;

            instanceCount = 1;
            baseInstance = 0;
	    }
	    virtual ~IMeshBuffer()
	    {
            if (leakDebugger)
                leakDebugger->deregisterObj(this);

            if (meshLayout)
                meshLayout->drop();
	    }


	    inline IMeshDataFormatDesc<T>* getMeshDataAndFormat() {return meshLayout;}
	    inline const IMeshDataFormatDesc<T>* getMeshDataAndFormat() const {return meshLayout;}
	    inline void setMeshDataAndFormat(IMeshDataFormatDesc<T>* layout)
	    {
	        if (layout)
                layout->grab();

	        if (meshLayout)
                meshLayout->drop();
            meshLayout = layout;
	    }

		//! Get type of index data which is stored in this meshbuffer.
		/** \return Index type of this buffer. */
		inline const video::E_INDEX_TYPE& getIndexType() const {return indexType;}
		inline void setIndexType(const video::E_INDEX_TYPE& type) {indexType = type;}

		inline void setIndexBufferOffset(const size_t& byteOffset) {indexBufOffset = byteOffset;}
		inline const size_t& getIndexBufferOffset() const {return indexBufOffset;}

		//! Get amount of indices in this meshbuffer.
		/** \return Number of indices in this buffer. */
		inline const uint64_t& getIndexCount() const {return indexCount;}
		inline bool setIndexCount(const uint64_t &newIndexCount)
		{
/*
#ifdef _DEBUG
            if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
            {
                os::Printer::log("MeshBuffer map vertex buffer overflow!\n",ELL_ERROR);
                return;
            }
#endif // _DEBUG
*/
            indexCount = newIndexCount;
            if (meshLayout)
            {
                const T* mappedIndexBuf = meshLayout->getIndexBuffer();
                if (mappedIndexBuf)
                {
                    switch (indexType)
                    {
                        case video::EIT_16BIT:
                            return indexCount*2+indexBufOffset<mappedIndexBuf->getSize();
                        case video::EIT_32BIT:
                            return indexCount*4+indexBufOffset<mappedIndexBuf->getSize();
                        default:
                            return false;
                    }
                }
            }

            return true;
		}


        inline const int32_t& getBaseVertex() const {return baseVertex;}
        inline void setBaseVertex(const int32_t& baseVx)
        {
            baseVertex = baseVx;
        }


		inline const scene::E_PRIMITIVE_TYPE& getPrimitiveType() const {return primitiveType;}
		inline void setPrimitiveType(const scene::E_PRIMITIVE_TYPE& type)
		{
		    primitiveType = type;
		}

		inline const size_t& getInstanceCount() const {return instanceCount;}
		inline void setInstanceCount(const size_t& count)
		{
		    instanceCount = count;
		}

		inline const uint32_t& getBaseInstance() const {return baseInstance;}
		inline void setBaseInstance(const uint32_t& base)
		{
		    baseInstance = base;
		}


		//! Get the axis aligned bounding box of this meshbuffer.
		/** \return Axis aligned bounding box of this buffer. */
		inline const core::aabbox3df& getBoundingBox() const {return boundingBox;}

		//! Set axis aligned bounding box
		/** \param box User defined axis aligned bounding box to use
		for this buffer. */
		inline void setBoundingBox(const core::aabbox3df& box)
		{
		    boundingBox = box;
		}

		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline const video::SMaterial& getMaterial() const
		{
			return Material;
		}


		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline video::SMaterial& getMaterial()
		{
			return Material;
		}
	};




	class ICPUMeshBuffer : public IMeshBuffer<core::ICPUBuffer>
	{
	    //vertices
	    E_VERTEX_ATTRIBUTE_ID posAttrId;
	public:
	    ICPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<core::ICPUBuffer>(NULL,dbgr), posAttrId(EVAI_ATTR0) {}


        inline const E_VERTEX_ATTRIBUTE_ID& getPositionAttributeIx() const {return posAttrId;}
        inline void setPositionAttributeIx(const E_VERTEX_ATTRIBUTE_ID& attrId)
        {
            if (attrId>=EVAI_COUNT)
#ifdef _DEBUG
            {
                //os::Printer::log("MeshBuffer setPositionAttributeIx attribute ID out of range!\n",ELL_ERROR);
                return;
            }
#else
                return;
#endif // _DEBUG

            posAttrId = attrId;
        }

		//! Get access to Indices.
		/** \return Pointer to indices array. */
		inline void* getIndices()
		{
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

        inline const void* getIndices() const
        {
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((const uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

        virtual core::vectorSIMDf getPosition(size_t ix) const
        {
            core::vectorSIMDf outPos(0.f,0.f,0.f,1.f);
            bool success = getAttribute(outPos,posAttrId,ix);
#ifdef _DEBUG
            if (!success)
            {
                //os::Printer::log("SOME DEBUG MESSAGE!\n",ELL_ERROR);
            }
#endif // _DEBUG
		    return outPos;
        }

        virtual uint8_t* getAttribPointer(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
		    if (!meshLayout)
                return NULL;

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (attrId>=EVAI_COUNT||!mappedAttrBuf)
                return NULL;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            if (!validCombination(attrType,components))
                return NULL;


            int64_t ix = baseVertex;
            ix *= meshLayout->getMappedBufferStride(attrId);
            ix += meshLayout->getMappedBufferOffset(attrId);
            if (ix<0||ix>=mappedAttrBuf->getSize())
                return NULL;

            return ((uint8_t*)mappedAttrBuf->getPointer())+ix;
        }

        virtual bool getAttribute(core::vectorSIMDf& output, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
            const uint8_t* vxPtr = const_cast<const uint8_t*>(getAttribPointer(attrId));
            if (!vxPtr)
                return false;
            vxPtr += ix*meshLayout->getMappedBufferStride(attrId);
            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (vxPtr-((uint8_t*)mappedAttrBuf->getPointer())>=mappedAttrBuf->getSize())
                return false;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            //! ECPA_REVERSED_OR_BGRA not DONE CORRECTLY
            switch (attrType)
            {
                case ECT_FLOAT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((float*)vxPtr)[j];
                    return true;
                    break;
                case ECT_HALF_FLOAT:
                    {
#ifdef _DEBUG
                        //os::Printer::log("HALF FLOAT BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_DOUBLE_IN_FLOAT_OUT:
                case ECT_DOUBLE_IN_DOUBLE_OUT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((double*)vxPtr)[j];
                    return true;
                    break;
                case ECT_UNSIGNED_INT_10F_11F_11F_REV:
                    {
#ifdef _DEBUG
                        //os::Printer::log("UNSIGNED_INT_10F_11F_11F_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INT_2_10_10_10_REV:
                case ECT_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INTEGER_INT_2_10_10_10_REV:
                case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        output.pointer[0] = 0x3ffu&(((uint32_t*)vxPtr)[0]);
                        output.pointer[1] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>10);
                        output.pointer[2] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>20);
                        output.pointer[3] = ((uint32_t*)vxPtr)[0]>>30;
                    }
                    else
                    {/*
                        output.pointer[3] = 0x3ffu&(((uint32_t*)vxPtr)[0]);
                        output.pointer[0] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>10);
                        output.pointer[1] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>20);
                        output.pointer[2] = ((uint32_t*)vxPtr)[0]>>30;*/
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_UNSIGNED_BYTE:
                case ECT_BYTE:
                case ECT_UNSIGNED_BYTE:
                case ECT_INTEGER_BYTE:
                case ECT_INTEGER_UNSIGNED_BYTE:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        for (size_t j=0; j<components; j++)
                            output.pointer[j] = ((uint8_t*)vxPtr)[j];
                    }
                    else
                    {
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_UNSIGNED_SHORT:
                case ECT_SHORT:
                case ECT_UNSIGNED_SHORT:
                case ECT_INTEGER_SHORT:
                case ECT_INTEGER_UNSIGNED_SHORT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((uint16_t*)vxPtr)[j];
                    break;
                case ECT_NORMALIZED_INT:
                case ECT_NORMALIZED_UNSIGNED_INT:
                case ECT_INT:
                case ECT_UNSIGNED_INT:
                case ECT_INTEGER_INT:
                case ECT_INTEGER_UNSIGNED_INT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((uint32_t*)vxPtr)[j];
                    break;
                default:
                    return false;
            }

            core::vectorSIMDf subs[4][ECPA_COUNT] = {
                {core::vectorSIMDf(2.f,512.f,512.f,512.f),core::vectorSIMDf(512.f,0.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,2.f)},
                {core::vectorSIMDf(128.f,128.f,128.f,128.f),core::vectorSIMDf(128.f,0.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,128.f)},
                {core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f),core::vectorSIMDf(32768.f,0.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f)},
                {core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f),core::vectorSIMDf(2147483648.f,0.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f)}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_INT_2_10_10_10_REV:
                case ECT_INTEGER_INT_2_10_10_10_REV:
                    output -= subs[0][components];
                    break;
                case ECT_NORMALIZED_BYTE:
                case ECT_BYTE:
                case ECT_INTEGER_BYTE:
                    output -= subs[1][components];
                    break;
                case ECT_NORMALIZED_SHORT:
                case ECT_SHORT:
                case ECT_INTEGER_SHORT:
                    output -= subs[2][components];
                    break;
                case ECT_NORMALIZED_INT:
                case ECT_INT:
                case ECT_INTEGER_INT:
                    output -= subs[3][components];
                    break;
                default:
                    break;
            }

            core::vectorSIMDf divisors[8][ECPA_COUNT] = {
                {core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f)},
                {core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f)},
                {core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f)},
                {core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f)},
                {core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f)},
                {core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f)},
                {core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f)},
                {core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f)}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                    output /= divisors[0][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                    output /= divisors[1][components];
                    break;
                case ECT_NORMALIZED_BYTE:
                    output /= divisors[2][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_BYTE:
                    output /= divisors[3][components];
                    break;
                case ECT_NORMALIZED_SHORT:
                    output /= divisors[4][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_SHORT:
                    output /= divisors[5][components];
                    break;
                case ECT_NORMALIZED_INT:
                    output /= divisors[6][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_INT:
                    output /= divisors[7][components];
                    break;
                default:
                    break;
            }

            uint32_t outMasksBits[ECPA_COUNT][4] = {
                {0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu},
                {0xffffffffu,0,0,0},
                {0xffffffffu,0xffffffffu,0,0},
                {0xffffffffu,0xffffffffu,0xffffffffu,0},
                {0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu}
            };
            uint32_t outMasksBitsInv[ECPA_COUNT][4] = {
                {0,0,0,0},
                {0,0xffffffffu,0xffffffffu,0xffffffffu},
                {0,0,0xffffffffu,0xffffffffu},
                {0,0,0,0xffffffffu},
                {0,0,0,0}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_INT:
                    {
                        core::vectorSIMDf outputMask,outputMaskInv;
                        outputMask.set((float*)(outMasksBits[components]));
                        outputMaskInv.set((float*)(outMasksBitsInv[components]));
                        output = (max_(output,core::vectorSIMDf(-1.f,-1.f,-1.f,-1.f))&outputMask)|(outputMaskInv&output);
                    }
                    break;
                default:
                    break;
            }

            return true;
        }

        virtual bool setAttribute(core::vectorSIMDf input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
            uint8_t* vxPtr = getAttribPointer(attrId);
            if (!vxPtr)
                return false;
            vxPtr += ix*meshLayout->getMappedBufferStride(attrId);

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            switch (attrType)
            {
                case ECT_FLOAT:
                    for (size_t j=0; j<components; j++)
                        ((float*)vxPtr)[j] = input.pointer[j];
                    return true;
                    break;
                case ECT_HALF_FLOAT:
                    {
#ifdef _DEBUG
                        //os::Printer::log("HALF FLOAT SET NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_DOUBLE_IN_FLOAT_OUT:
                case ECT_DOUBLE_IN_DOUBLE_OUT:
                    for (size_t j=0; j<components; j++)
                        ((double*)vxPtr)[j] = input.pointer[j];
                    return true;
                    break;
                case ECT_UNSIGNED_INT_10F_11F_11F_REV:
                    {
#ifdef _DEBUG
                        //os::Printer::log("UNSIGNED_INT_10F_11F_11F_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_INT:
                    input += 1.f;
                    break;
                default:
                    {
                        //! ECPA_REVERSED_OR_BGRA not DONE CORRECTLY
                        if (components==ECPA_REVERSED_OR_BGRA)
                            return false;
#ifdef _DEBUG
                        //os::Printer::log("SETTING INTEGER VERTEX ATTRIBUTE COMPONENTS FROM vectorSIMDf NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                        /**

            if normalized convert up,

            cast to int64_t

                        core::vectorSIMDf divisors[8][ECPA_COUNT] = {
                            {core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f)},
                            {core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f)},
                            {core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f)},
                            {core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f)},
                            {core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f)},
                            {core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f)},
                            {core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f)},
                            {core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f)}
                        };
                        int64_t results[4];
                        switch (attrType)
                        {
                            case ECT_NORMALIZED_INT_2_10_10_10_REV:
                            case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                            case ECT_NORMALIZED_BYTE:
                            case ECT_NORMALIZED_UNSIGNED_BYTE:
                            case ECT_NORMALIZED_SHORT:
                            case ECT_NORMALIZED_UNSIGNED_SHORT:
                            case ECT_NORMALIZED_INT:
                            case ECT_NORMALIZED_UNSIGNED_INT:
                                break;
                        }
                        for (size_t j=0; j<components; j++)
                            results[j] = input.pointer[j];**/
                    }
                    break;

            }

            return false;
        }

        virtual bool setAttribute(uint32_t* input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
            uint8_t* vxPtr = getAttribPointer(attrId);
            if (!vxPtr)
                return false;
            vxPtr += ix*meshLayout->getMappedBufferStride(attrId);

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            switch (attrType)
            {
                case ECT_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
                    if (components==ECPA_FOUR)
                    {
                        reinterpret_cast<uint32_t*>(vxPtr)[0] = (input[0]&0x3ffu)|((input[1]&0x3ffu)<<10)|((input[2]&0x3ffu)<<20)|((input[3]&0x3u)<<30);
                    }/*
                    else if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        reinterpret_cast<uint32_t*>(vxPtr)[0] = (input[0]&0x3ffu)|((input[1]&0x3ffu)<<10)|((input[2]&0x3ffu)<<20)|((input[3]&0x3u)<<30);
                    }*/
                    else
                    {
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_UNSIGNED_BYTE:
                case ECT_INTEGER_UNSIGNED_BYTE:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        for (size_t j=0; j<components; j++)
                            reinterpret_cast<uint8_t*>(vxPtr)[j] = input[j];
                    }
                    else
                    {
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_UNSIGNED_SHORT:
                case ECT_INTEGER_UNSIGNED_SHORT:
                    for (size_t j=0; j<components; j++)
                        reinterpret_cast<uint16_t*>(vxPtr)[j] = input[j];
                    return true;
                    break;
                case ECT_UNSIGNED_INT:
                case ECT_INTEGER_UNSIGNED_INT:
                    for (size_t j=0; j<components; j++)
                        reinterpret_cast<uint32_t*>(vxPtr)[j] = input[j];
                    return true;
                    break;
                default:
                    return false;
                    break;

            }

            return false;
        }

		//! Recalculates the bounding box. Should be called if the mesh changed.
		virtual void recalculateBoundingBox()
		{
		    if (!meshLayout)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(posAttrId);
            if (posAttrId>=EVAI_COUNT||!mappedAttrBuf)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

		    if (!validCombination(meshLayout->getAttribType(posAttrId),meshLayout->getAttribComponentCount(posAttrId)))
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            for (size_t j=0; j<indexCount; j++)
            {
                size_t ix;
                void* indices = getIndices();
                if (indices)
                {
                    switch(indexType)
                    {
                        case video::EIT_32BIT:
                            ix  = ((uint32_t*)indices)[j];
                            break;
                        case video::EIT_16BIT:
                            ix  = ((uint16_t*)indices)[j];
                            break;
                        default:
                            return;
                    }
                }
                else
                    ix = j;


                if (j)
                    boundingBox.addInternalPoint(getPosition(ix).getAsVector3df());
                else
                    boundingBox.reset(getPosition(ix).getAsVector3df());
            }
		}
	};

	class IGPUMeshBuffer : public IMeshBuffer<video::IGPUBuffer>
	{
            video::ITransformFeedback* attachedXFormFeedback;
            uint32_t attachedXFormFeedbackStream;
        public:
            IGPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<video::IGPUBuffer>(NULL,dbgr), attachedXFormFeedback(NULL), attachedXFormFeedbackStream(0) {}
            virtual ~IGPUMeshBuffer()
            {
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
            }

            inline void setIndexCountFromXFormFeedback(video::ITransformFeedback* xformFeedback, const uint32_t & stream)
            {
                attachedXFormFeedbackStream = stream;


                if (xformFeedback==attachedXFormFeedback)
                    return;

                if (!xformFeedback)
                {
                    if (attachedXFormFeedback)
                        attachedXFormFeedback->drop();

                    attachedXFormFeedback = NULL;
                    return;
                }

                xformFeedback->grab();
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
                attachedXFormFeedback = xformFeedback;

                indexType = video::EIT_UNKNOWN;
                indexCount = 0;
            }

            inline video::ITransformFeedback* getXFormFeedback() const {return attachedXFormFeedback;}

            inline const uint32_t& getXFormFeedbackStream() const {return attachedXFormFeedbackStream;}

            bool isIndexCountGivenByXFormFeedback() const {return attachedXFormFeedback!=NULL;}
	};

#include "irrpack.h"
    class SkinnedVertexIntermediateData
    {
        public:
            SkinnedVertexIntermediateData()
            {
                memset(this,0,20);
            }
            uint8_t boneIDs[4];
            float boneWeights[4];
    } PACK_STRUCT;

    struct SkinnedVertexFinalData
    {
        public:
            uint8_t boneIDs[4];
            uint32_t boneWeights; //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
    } PACK_STRUCT;
#include "irrunpack.h"

} // end namespace scene
} // end namespace irr

#endif


