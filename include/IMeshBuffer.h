// Copyright (C) 2002-2012 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine".
// For conditions of distribution and use, see copyright notice in irrlicht.h

#ifndef __I_MESH_BUFFER_H_INCLUDED__
#define __I_MESH_BUFFER_H_INCLUDED__

#include "IReferenceCounted.h"
#include "SMaterial.h"
#include "aabbox3d.h"
#include "SVertexIndex.h"
#include "EPrimitiveTypes.h"
#include "ICPUBuffer.h"
#include "IGPUBuffer.h"
#include "SMaterial.h"
#include "vectorSIMD.h"
//#include "os.h"

namespace irr
{
namespace scene
{

    enum E_VERTEX_ATTRIBUTE_ID
    {
        EVAI_ATTR0=0,
        EVAI_ATTR1,
        EVAI_ATTR2,
        EVAI_ATTR3,
        EVAI_ATTR4,
        EVAI_ATTR5,
        EVAI_ATTR6,
        EVAI_ATTR7,
        EVAI_ATTR8,
        EVAI_ATTR9,
        EVAI_ATTR10,
        EVAI_ATTR11,
        EVAI_ATTR12,
        EVAI_ATTR13,
        EVAI_ATTR14,
        EVAI_ATTR15,
        EVAI_COUNT
    };

    enum E_COMPONENTS_PER_ATTRIBUTE
    {
        ECPA_REVERSED_OR_BGRA=0,
        ECPA_ONE,
        ECPA_TWO,
        ECPA_THREE,
        ECPA_FOUR,
        ECPA_COUNT
    };

    enum E_COMPONENT_TYPE
    {
        ECT_FLOAT=0,
        ECT_HALF_FLOAT,
        ECT_DOUBLE_IN_FLOAT_OUT,
        ECT_UNSIGNED_INT_10F_11F_11F_REV,
        //INTEGER FORMS
        ECT_NORMALIZED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_BYTE,
        ECT_NORMALIZED_UNSIGNED_BYTE,
        ECT_NORMALIZED_SHORT,
        ECT_NORMALIZED_UNSIGNED_SHORT,
        ECT_NORMALIZED_INT,
        ECT_NORMALIZED_UNSIGNED_INT,
        ECT_INT_2_10_10_10_REV,
        ECT_UNSIGNED_INT_2_10_10_10_REV,
        ECT_BYTE,
        ECT_UNSIGNED_BYTE,
        ECT_SHORT,
        ECT_UNSIGNED_SHORT,
        ECT_INT,
        ECT_UNSIGNED_INT,
        ECT_INTEGER_INT_2_10_10_10_REV,
        ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV,
        ECT_INTEGER_BYTE,
        ECT_INTEGER_UNSIGNED_BYTE,
        ECT_INTEGER_SHORT,
        ECT_INTEGER_UNSIGNED_SHORT,
        ECT_INTEGER_INT,
        ECT_INTEGER_UNSIGNED_INT,
        //special
        ECT_DOUBLE_IN_DOUBLE_OUT, //only accepted by glVertexAttribLPointer
        ECT_COUNT
    };
/**
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.

GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.

GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.

GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
**/
    static size_t vertexAttrSize[ECT_COUNT][ECPA_COUNT] = {
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,8,16,24,32},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4,0xdeadbeefu}, //ECT_UNSIGNED_INT_10F_11F_11F_REV
        //integers
        //normalized
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_INT_2_10_10_10_REV
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, //ECT_NORMALIZED_BYTE
        {4,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //un normalized ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //native ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //special
        {0xdeadbeefu,8,16,24,32}
    };

    inline bool validCombination(const E_COMPONENT_TYPE& type, const E_COMPONENTS_PER_ATTRIBUTE& components)
    {
        return vertexAttrSize[type][components]<0xdeadbeefu;
    }

    inline bool isNormalized(const E_COMPONENT_TYPE& type)
    {
        return type>=ECT_NORMALIZED_INT_2_10_10_10_REV&&type<=ECT_NORMALIZED_UNSIGNED_INT;
    }



	template <class T>
	class IMeshDataFormatDesc : public virtual IReferenceCounted
	{
    protected:
	    //vertices
            E_COMPONENTS_PER_ATTRIBUTE compntsPerAttr[EVAI_COUNT];
            E_COMPONENT_TYPE attrType[EVAI_COUNT];
            size_t attrStride[EVAI_COUNT];
            size_t attrOffset[EVAI_COUNT];
            T* mappedAttrBuf[EVAI_COUNT];
	    //indices
	    T* mappedIndexBuf;
	public:
	    IMeshDataFormatDesc()
	    {
            for (size_t i=0; i<EVAI_COUNT; i++)
            {
                compntsPerAttr[i] = ECPA_FOUR;
                attrType[i] = ECT_FLOAT;
                attrStride[i] = 16;
                attrOffset[i] = 0;
                mappedAttrBuf[i] = NULL;
            }

            mappedIndexBuf = NULL;
	    }
	    virtual ~IMeshDataFormatDesc()
	    {
            for (size_t i=0; i<EVAI_COUNT; i++)
            {
                if (mappedAttrBuf[i])
                    mappedAttrBuf[i]->drop();
            }

            if (mappedIndexBuf)
                mappedIndexBuf->drop();
	    }

		virtual void mapIndexBuffer(T* ixbuf) = 0;

		inline const T* getIndexBuffer() const {return mappedIndexBuf;}


        virtual void mapVertexAttrBuffer(T* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0) = 0;

        inline const T* getMappedBuffer(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return NULL;

            return mappedAttrBuf[attrId];
        }

        inline E_COMPONENT_TYPE getAttribType(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return ECT_COUNT;

            return attrType[attrId];
        }

        inline E_COMPONENTS_PER_ATTRIBUTE getAttribComponentCount(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return ECPA_COUNT;

            return compntsPerAttr[attrId];
        }

        inline size_t getMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return 0;

            return attrOffset[attrId];
        }

        inline size_t getMappedBufferStride(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
            if (attrId>=EVAI_COUNT)
                return 0;

            return attrStride[attrId];
        }
	};


	class ICPUMeshDataFormatDesc : public IMeshDataFormatDesc<core::ICPUBuffer>
	{
	    public:
            void mapIndexBuffer(core::ICPUBuffer* ixbuf)
            {
        /*
        #ifdef _DEBUG
                if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
                {
                    os::Printer::log("MeshBuffer map index buffer overflow!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG
        */
                if (ixbuf)
                    ixbuf->grab();

                if (mappedIndexBuf)
                    mappedIndexBuf->drop();
                mappedIndexBuf = ixbuf;
            }

            void mapVertexAttrBuffer(core::ICPUBuffer* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0)
            {
                if (attrId>=EVAI_COUNT)
        #ifdef _DEBUG
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer attribute ID out of range!\n",ELL_ERROR);
                    return;
                }

                if (!validCombination(type,components))
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer INVALID COMBINATION OF COMPONENT TYPE AND COUNT!\n",ELL_ERROR);
                    return;
                }
        #else
                    return;
        #endif // _DEBUG

                if (attrBuf)
                {
                    attrBuf->grab();

                    compntsPerAttr[attrId] = components;
                    attrType[attrId] = type;
                    attrStride[attrId] = stride!=0 ? stride:vertexAttrSize[type][components];
                    attrOffset[attrId] = offset;
                }
                else
                {
                    compntsPerAttr[attrId] = ECPA_FOUR;
                    attrType[attrId] = ECT_FLOAT;
                    attrStride[attrId] = 16;
                    attrOffset[attrId] = 0;
                }

                if (mappedAttrBuf[attrId])
                    mappedAttrBuf[attrId]->drop();
                mappedAttrBuf[attrId] = attrBuf;
            }
	};

	typedef IMeshDataFormatDesc<video::IGPUBuffer> IGPUMeshDataFormatDesc;




	template <class T>
	class IMeshBuffer : public virtual IReferenceCounted
	{
    protected:
        video::SMaterial Material;
        core::aabbox3df boundingBox;
        IMeshDataFormatDesc<T>* meshLayout;
	    //indices
	    video::E_INDEX_TYPE indexType;
	    uint32_t baseVertex;
        uint64_t indexCount;
        size_t indexBufOffset;
        //primitives
        scene::E_PRIMITIVE_TYPE primitiveType;
	public:
	    IMeshBuffer(IMeshDataFormatDesc<T>* layout=NULL)
	    {
	        meshLayout = layout;
	        if (meshLayout)
                meshLayout->grab();

            indexType = video::EIT_UNKNOWN;
            baseVertex = 0;
            indexCount = 0;
            indexBufOffset = 0;

	        primitiveType = scene::EPT_TRIANGLES;
	    }
	    virtual ~IMeshBuffer()
	    {
            if (meshLayout)
                meshLayout->drop();
	    }


	    inline IMeshDataFormatDesc<T>* getMeshDataAndFormat() {return meshLayout;}
	    inline const IMeshDataFormatDesc<T>* getMeshDataAndFormat() const {return meshLayout;}
	    inline void setMeshDataAndFormat(IMeshDataFormatDesc<T>* layout)
	    {
	        layout->grab();
	        if (meshLayout)
                meshLayout->drop();
            meshLayout = layout;
	    }

		//! Get type of index data which is stored in this meshbuffer.
		/** \return Index type of this buffer. */
		inline const video::E_INDEX_TYPE& getIndexType() const {return indexType;}
		inline void setIndexType(const video::E_INDEX_TYPE& type) {indexType = type;}

		inline void setIndexBufferOffset(const size_t& byteOffset) {indexBufOffset = byteOffset;}
		inline const size_t& getIndexBufferOffset() const {return indexBufOffset;}

		//! Get amount of indices in this meshbuffer.
		/** \return Number of indices in this buffer. */
		inline const uint64_t& getIndexCount() const {return indexCount;}
		inline bool setIndexCount(const uint64_t &newIndexCount)
		{
/*
#ifdef _DEBUG
            if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
            {
                os::Printer::log("MeshBuffer map vertex buffer overflow!\n",ELL_ERROR);
                return;
            }
#endif // _DEBUG
*/
            indexCount = newIndexCount;
            if (meshLayout)
            {
                const T* mappedIndexBuf = meshLayout->getIndexBuffer();
                if (mappedIndexBuf)
                {
                    switch (indexType)
                    {
                        case video::EIT_16BIT:
                            return indexCount*2+indexBufOffset<mappedIndexBuf->getSize();
                        case video::EIT_32BIT:
                            return indexCount*4+indexBufOffset<mappedIndexBuf->getSize();
                        default:
                            return false;
                    }
                }
            }

            return true;
		}


        inline const uint32_t& getBaseVertex() const {return baseVertex;}
        inline void setBaseVertex(const uint32_t& baseVx)
        {
/*
#ifdef _DEBUG
            for (size_t i=0; i<EVAI_COUNT; i++)
            {
                if (mappedAttrBuf[i]&&mappedAttrBuf[i]->getSize()<=baseVx)
                {
                    os::Printer::log("MeshBuffer setBaseVertex buffer overflow!\n",ELL_ERROR);
                    return;
                }
            }
#endif // _DEBUG
*/
            baseVertex = baseVx;
        }


		inline const scene::E_PRIMITIVE_TYPE& getPrimitiveType() const {return primitiveType;}
		inline void setPrimitiveType(const scene::E_PRIMITIVE_TYPE& type)
		{
		    primitiveType = type;
		}

		//! Get the axis aligned bounding box of this meshbuffer.
		/** \return Axis aligned bounding box of this buffer. */
		inline const core::aabbox3df& getBoundingBox() const {return boundingBox;}

		//! Set axis aligned bounding box
		/** \param box User defined axis aligned bounding box to use
		for this buffer. */
		inline void setBoundingBox(const core::aabbox3df& box)
		{
		    boundingBox = box;
		}

		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline const video::SMaterial& getMaterial() const
		{
			return Material;
		}


		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline video::SMaterial& getMaterial()
		{
			return Material;
		}
	};

	class ICPUMeshBuffer : public virtual IMeshBuffer<core::ICPUBuffer>
	{
	    //vertices
	    E_VERTEX_ATTRIBUTE_ID posAttrId;
	public:
	    ICPUMeshBuffer() : posAttrId(EVAI_ATTR0) {}

        inline const E_VERTEX_ATTRIBUTE_ID& getPositionAttributeIx() const {return posAttrId;}
        inline void setPositionAttributeIx(const E_VERTEX_ATTRIBUTE_ID& attrId)
        {
            if (attrId>=EVAI_COUNT)
#ifdef _DEBUG
            {
                //os::Printer::log("MeshBuffer setPositionAttributeIx attribute ID out of range!\n",ELL_ERROR);
                return;
            }
#else
                return;
#endif // _DEBUG

            posAttrId = attrId;
        }

		//! Get access to Indices.
		/** \return Pointer to indices array. */
		inline void* getIndices()
		{
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

        inline const void* getIndices() const
        {
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((const uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

        virtual core::vectorSIMDf getPosition(size_t ix) const
        {
            core::vectorSIMDf outPos(0.f,0.f,0.f,1.f);
            bool success = getAttribute(outPos,posAttrId,ix);
#ifdef _DEBUG
            if (!success)
            {
                //os::Printer::log("SOME DEBUG MESSAGE!\n",ELL_ERROR);
            }
#endif // _DEBUG
		    return outPos;
        }

        virtual bool getAttribute(core::vectorSIMDf& output, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
		    if (!meshLayout)
                return false;

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (attrId>=EVAI_COUNT||!mappedAttrBuf)
                return false;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            if (!validCombination(attrType,components))
                return false;


            ix += baseVertex;
            ix *= meshLayout->getMappedBufferStride(attrId);
            ix += meshLayout->getMappedBufferOffset(attrId);
            if (ix>=mappedAttrBuf->getSize())
                return false;


            uint8_t* vxPtr = ((uint8_t*)mappedAttrBuf->getPointer())+ix;
            //! ECPA_REVERSED_OR_BGRA not DONE CORRECTLY
            switch (attrType)
            {
                case ECT_FLOAT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((float*)vxPtr)[j];
                    break;
                case ECT_HALF_FLOAT:
                    {
#ifdef _DEBUG
                        //os::Printer::log("HALF FLOAT BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_DOUBLE_IN_FLOAT_OUT:
                case ECT_DOUBLE_IN_DOUBLE_OUT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((double*)vxPtr)[j];
                    break;
                case ECT_UNSIGNED_INT_10F_11F_11F_REV:
                    {
#ifdef _DEBUG
                        //os::Printer::log("UNSIGNED_INT_10F_11F_11F_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INT_2_10_10_10_REV:
                case ECT_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INTEGER_INT_2_10_10_10_REV:
                case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
                    if (components==ECPA_REVERSED_OR_BGRA)
                    {/*
                        output.pointer[3] = 0x3ffu&(((uint32_t*)vxPtr)[0]);
                        output.pointer[0] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>10);
                        output.pointer[1] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>20);
                        output.pointer[2] = ((uint32_t*)vxPtr)[0]>>30;*/
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    else
                    {
                        output.pointer[0] = 0x3ffu&(((uint32_t*)vxPtr)[0]);
                        output.pointer[1] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>10);
                        output.pointer[2] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>20);
                        output.pointer[3] = ((uint32_t*)vxPtr)[0]>>30;
                    }
                    break;
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_UNSIGNED_BYTE:
                case ECT_BYTE:
                case ECT_UNSIGNED_BYTE:
                case ECT_INTEGER_BYTE:
                case ECT_INTEGER_UNSIGNED_BYTE:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        for (size_t j=0; j<components; j++)
                            output.pointer[j] = ((uint8_t*)vxPtr)[j];
                    }
                    else
                        return false;
                    break;
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_UNSIGNED_SHORT:
                case ECT_SHORT:
                case ECT_UNSIGNED_SHORT:
                case ECT_INTEGER_SHORT:
                case ECT_INTEGER_UNSIGNED_SHORT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((uint16_t*)vxPtr)[j];
                    break;
                case ECT_NORMALIZED_INT:
                case ECT_NORMALIZED_UNSIGNED_INT:
                case ECT_INT:
                case ECT_UNSIGNED_INT:
                case ECT_INTEGER_INT:
                case ECT_INTEGER_UNSIGNED_INT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((uint32_t*)vxPtr)[j];
                    break;
                default:
                    return false;
            }

            core::vectorSIMDf subs[4][ECPA_COUNT] = {
                {core::vectorSIMDf(2.f,512.f,512.f,512.f),core::vectorSIMDf(512.f,0.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,2.f)},
                {core::vectorSIMDf(128.f,128.f,128.f,128.f),core::vectorSIMDf(128.f,0.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,128.f)},
                {core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f),core::vectorSIMDf(32768.f,0.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f)},
                {core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f),core::vectorSIMDf(2147483648.f,0.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f)}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_INT_2_10_10_10_REV:
                case ECT_INTEGER_INT_2_10_10_10_REV:
                    output -= subs[0][components];
                    break;
                case ECT_NORMALIZED_BYTE:
                case ECT_BYTE:
                case ECT_INTEGER_BYTE:
                    output -= subs[1][components];
                    break;
                case ECT_NORMALIZED_SHORT:
                case ECT_SHORT:
                case ECT_INTEGER_SHORT:
                    output -= subs[2][components];
                    break;
                case ECT_NORMALIZED_INT:
                case ECT_INT:
                case ECT_INTEGER_INT:
                    output -= subs[3][components];
                    break;
                default:
                    break;
            }

            core::vectorSIMDf divisors[8][ECPA_COUNT] = {
                {core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f)},
                {core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f)},
                {core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f)},
                {core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f)},
                {core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f)},
                {core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f)},
                {core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f)},
                {core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f)}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                    output /= divisors[0][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                    output /= divisors[1][components];
                    break;
                case ECT_NORMALIZED_BYTE:
                    output /= divisors[2][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_BYTE:
                    output /= divisors[3][components];
                    break;
                case ECT_NORMALIZED_SHORT:
                    output /= divisors[4][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_SHORT:
                    output /= divisors[5][components];
                    break;
                case ECT_NORMALIZED_INT:
                    output /= divisors[6][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_INT:
                    output /= divisors[7][components];
                    break;
                default:
                    break;
            }

            uint32_t outMasksBits[ECPA_COUNT][4] = {
                {0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu},
                {0xffffffffu,0,0,0},
                {0xffffffffu,0xffffffffu,0,0},
                {0xffffffffu,0xffffffffu,0xffffffffu,0},
                {0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu}
            };
            uint32_t outMasksBitsInv[ECPA_COUNT][4] = {
                {0,0,0,0},
                {0,0xffffffffu,0xffffffffu,0xffffffffu},
                {0,0,0xffffffffu,0xffffffffu},
                {0,0,0,0xffffffffu},
                {0,0,0,0}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_INT:
                    {
                        core::vectorSIMDf outputMask,outputMaskInv;
                        outputMask.set((float*)(outMasksBits[components]));
                        outputMaskInv.set((float*)(outMasksBitsInv[components]));
                        output = (max_(output,core::vectorSIMDf(-1.f,-1.f,-1.f,-1.f))&outputMask)|(outputMaskInv&output);
                    }
                    break;
                default:
                    break;
            }

            return true;
        }

        virtual bool setAttribute(core::vectorSIMDf input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
		    if (!meshLayout)
                return false;

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (attrId>=EVAI_COUNT||!mappedAttrBuf)
                return false;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            if (!validCombination(attrType,components))
                return false;


            ix += baseVertex;
            ix *= meshLayout->getMappedBufferStride(attrId);
            ix += meshLayout->getMappedBufferOffset(attrId);
            if (ix>=mappedAttrBuf->getSize())
                return false;


            uint8_t* vxPtr = ((uint8_t*)mappedAttrBuf->getPointer())+ix;
            switch (attrType)
            {
                case ECT_FLOAT:
                    for (size_t j=0; j<components; j++)
                        ((float*)vxPtr)[j] = input.pointer[j];
                    return true;
                case ECT_HALF_FLOAT:
                    {
#ifdef _DEBUG
                        //os::Printer::log("HALF FLOAT SET NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                case ECT_DOUBLE_IN_FLOAT_OUT:
                case ECT_DOUBLE_IN_DOUBLE_OUT:
                    for (size_t j=0; j<components; j++)
                        ((double*)vxPtr)[j] = input.pointer[j];
                    return true;
                case ECT_UNSIGNED_INT_10F_11F_11F_REV:
                    {
#ifdef _DEBUG
                        //os::Printer::log("UNSIGNED_INT_10F_11F_11F_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                default:
                    {
                        //! ECPA_REVERSED_OR_BGRA not DONE CORRECTLY
                        if (components==ECPA_REVERSED_OR_BGRA)
                            return false;
#ifdef _DEBUG
                        //os::Printer::log("SETTING INTEGER VERTEX ATTRIBUTE COMPONENTS FROM vectorSIMDf NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                        /**

            if normalized convert up,

            cast to int64_t

                        core::vectorSIMDf divisors[8][ECPA_COUNT] = {
                            {core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f)},
                            {core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f)},
                            {core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f)},
                            {core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f)},
                            {core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f)},
                            {core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f)},
                            {core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f)},
                            {core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f)}
                        };
                        int64_t results[4];
                        switch (attrType)
                        {
                            case ECT_NORMALIZED_INT_2_10_10_10_REV:
                            case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                            case ECT_NORMALIZED_BYTE:
                            case ECT_NORMALIZED_UNSIGNED_BYTE:
                            case ECT_NORMALIZED_SHORT:
                            case ECT_NORMALIZED_UNSIGNED_SHORT:
                            case ECT_NORMALIZED_INT:
                            case ECT_NORMALIZED_UNSIGNED_INT:
                                break;
                        }
                        for (size_t j=0; j<components; j++)
                            results[j] = input.pointer[j];**/
                    }
                    break;

            }

            return true;
        }

		//! Recalculates the bounding box. Should be called if the mesh changed.
		virtual void recalculateBoundingBox()
		{
		    if (!meshLayout)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(posAttrId);
            if (posAttrId>=EVAI_COUNT||!mappedAttrBuf)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

		    if (!validCombination(meshLayout->getAttribType(posAttrId),meshLayout->getAttribComponentCount(posAttrId)))
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            for (size_t j=0; j<indexCount; j++)
            {
                size_t ix;
                void* indices = getIndices();
                if (indices)
                {
                    switch(indexType)
                    {
                        case video::EIT_32BIT:
                            ix  = ((uint32_t*)indices)[j];
                            break;
                        case video::EIT_16BIT:
                            ix  = ((uint16_t*)indices)[j];
                            break;
                        default:
                            return;
                    }
                }
                else
                    ix = j;


                if (j)
                    boundingBox.addInternalPoint(getPosition(ix).getAsVector3df());
                else
                    boundingBox.reset(getPosition(ix).getAsVector3df());
            }
		}
	};

	class IGPUMeshBuffer : public virtual IMeshBuffer<video::IGPUBuffer>
	{
    protected:
	    uint32_t indexValMin;
	    uint32_t indexValMax;
	public:
	    IGPUMeshBuffer();
        void setIndexRange(const uint32_t &minBeforeBaseVxAdd, const uint32_t &maxBeforeBaseVxAdd);

        inline const uint32_t& getIndexMinBound() const {return indexValMin;}
        inline const uint32_t& getIndexMaxBound() const {return indexValMax;}
	};

} // end namespace scene
} // end namespace irr

#endif


