// For a 1024x1024 image
// WG_SIZE = 256x1x1
// VT = 4
// Number of workgroups = 1024

// Todo: DRY!!
#define WIDTH 1024
#define HEIGHT 1024
#define RADIUS 15.73f
#define VT 4

#ifndef _NBL_GLSL_EXT_BLUR_INPUT_SET_DEFINED_
#define _NBL_GLSL_EXT_BLUR_INPUT_SET_DEFINED_ 0
#endif

#ifndef _NBL_GLSL_EXT_BLUR_INPUT_BINDING_DEFINED_
#define _NBL_GLSL_EXT_BLUR_INPUT_BINDING_DEFINED_ 0
#endif

#ifndef _NBL_GLSL_EXT_BLUR_OUTPUT_SET_DEFINED_
#define _NBL_GLSL_EXT_BLUR_OUTPUT_SET_DEFINED_ 0
#endif

#ifndef _NBL_GLSL_EXT_BLUR_OUTPUT_BINDING_DEFINED_
#define _NBL_GLSL_EXT_BLUR_OUTPUT_BINDING_DEFINED_ 1
#endif

#define nbl_glsl_ext_Blur_Storage_t uvec2

nbl_glsl_ext_Blur_Storage_t nbl_glsl_ext_Blur_Storage_t_get(vec4 val)
{
	return nbl_glsl_ext_Blur_Storage_t(packHalf2x16(val.rg), packHalf2x16(val.ba));
}

vec4 nbl_glsl_ext_Blur_Storage_t_set(nbl_glsl_ext_Blur_Storage_t val)
{
	return vec4(unpackHalf2x16(val.x), unpackHalf2x16(val.y));
}

#ifndef _NBL_GLSL_EXT_BLUR_INPUT_DESCRIPTOR_DEFINED_

layout (set = _NBL_GLSL_EXT_BLUR_INPUT_SET_DEFINED_, binding = _NBL_GLSL_EXT_BLUR_INPUT_BINDING_DEFINED_, std430) restrict readonly buffer InputBuffer
{
	nbl_glsl_ext_Blur_Storage_t in_values[];
};

#define _NBL_GLSL_EXT_BLUR_INPUT_DESCRIPTOR_DEFINED_
#endif

#ifndef _NBL_GLSL_EXT_BLUR_OUTPUT_DESCRIPTOR_DEFINED_

layout (set = _NBL_GLSL_EXT_BLUR_OUTPUT_SET_DEFINED_, binding = _NBL_GLSL_EXT_BLUR_OUTPUT_BINDING_DEFINED_, std430) restrict writeonly buffer OutputBuffer
{
	nbl_glsl_ext_Blur_Storage_t out_values[];
};

#define _NBL_GLSL_EXT_BLUR_OUTPUT_DESCRIPTOR_DEFINED_
#endif

#ifndef _NBL_GLSL_EXT_BLUR_GET_PADDED_DATA_DEFINED_

vec4 nbl_glsl_ext_Blur_getPaddedData(in uint idx)
{
	uint strided_idx = (idx * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex; // y coordinate

	vec4 data = vec4(0.f);
	if (strided_idx < HEIGHT && gl_WorkGroupID.x < WIDTH)
		data = nbl_glsl_ext_Blur_Storage_t_set(in_values[strided_idx * WIDTH + gl_WorkGroupID.x]);

	return data;
}

#define _NBL_GLSL_EXT_BLUR_GET_PADDED_DATA_DEFINED_
#endif

#ifndef _NBL_GLSL_EXT_BLUR_SET_DATA_DEFINED_

void nbl_glsl_ext_Blur_setData(in uint idx, in vec4 val)
{
	uint strided_idx = (idx * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;

	if (strided_idx < WIDTH && gl_WorkGroupID.x < HEIGHT)
		out_values[gl_WorkGroupID.x * WIDTH + strided_idx] = nbl_glsl_ext_Blur_Storage_t_get(val);
}

#define _NBL_GLSL_EXT_BLUR_SET_DATA_DEFINED_
#endif

#include <nbl/builtin/glsl/workgroup/shared_arithmetic.glsl>

#if WIDTH < _NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_
	#define _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_ _NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_
#else
	#define _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_ WIDTH
#endif

#ifdef _NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_
	#if NBL_GLSL_EVAL(_NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_) < NBL_GLSL_EVAL(_NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_)
		#error "Not enough shared memory declared"
	#endif
#else
    #define _NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_ _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_
    #define _NBL_GLSL_SCRATCH_SHARED_DEFINED_ nbl_glsl_ext_Blur_scratchShared
	shared uint _NBL_GLSL_SCRATCH_SHARED_DEFINED_[_NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_];
#endif

// Todo: Need to test and tighten this whole spillage calculation up
#define _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_ ((_NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_-1)/_NBL_GLSL_WORKGROUP_SIZE_+1)

#if _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_ > VT
	#define _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_ VT
#elif _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_ < (VT/4)
	#define _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_ (VT/4)
#else
	#define _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_ _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_
#endif

#include <nbl/builtin/glsl/workgroup/arithmetic.glsl>
#include <nbl/builtin/glsl/workgroup/ballot.glsl>

// Convenience thing
#define scratch_shared _NBL_GLSL_SCRATCH_SHARED_DEFINED_

// Note(achal): This function depends on `scratch_shared` to be properly initialized with inclusive prefix sums
// Todo(achal): You can't have it depend on `scratch_shared` --das not gud
float getInterpolatedPrefixSums(float idx)
{
	uint floored = uint(floor(idx));
	return mix(uintBitsToFloat(scratch_shared[floored]), uintBitsToFloat(scratch_shared[floored + 1u]), fract(idx));
}

void main()
{
	const uint channel_count = 3u;
	const uint pass_count = 3u;

	vec4 blurred[VT];
	for (uint i = 0u; i < VT; ++i)
		blurred[i] = nbl_glsl_ext_Blur_getPaddedData(i);

	for (uint ch = 0; ch < channel_count; ++ch)
	{
		for (uint pass = 0; pass < pass_count; ++pass)
		{
			float previous_block_sum = 0.f;
	
			float spill[_NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_];
			for (uint i = 0u; i < _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; ++i)
			{
			    spill[i] = nbl_glsl_workgroupInclusiveAdd(blurred[i][ch]) + previous_block_sum;
			    previous_block_sum = nbl_glsl_workgroupBroadcast(spill[i], _NBL_GLSL_WORKGROUP_SIZE_ - 1u);
			}
	
			for (uint i = _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; i < VT; ++i)
			{
			    float scan_result = nbl_glsl_workgroupInclusiveAdd(blurred[i][ch]) + previous_block_sum;
			    previous_block_sum = nbl_glsl_workgroupBroadcast(scan_result,  _NBL_GLSL_WORKGROUP_SIZE_ - 1u);
	
				uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
			    scratch_shared[idx] = floatBitsToUint(scan_result);
			}
	
			for (uint i = 0u; i < _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; ++i)
			    scratch_shared[(i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex] = floatBitsToUint(spill[i]);
			barrier();
			
			for (uint i = 0; i < VT; ++i)
			{
				uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
				if (idx < WIDTH)
				{
					float left = float(idx) - RADIUS - 1.f;
					float right = float(idx) + RADIUS;
	
					const uint last = WIDTH - 1u;
	
					float result;
					if (right > last)
						result = (right - float(last)) * (uintBitsToFloat(scratch_shared[last]) - uintBitsToFloat(scratch_shared[last - 1u])) + uintBitsToFloat(scratch_shared[last]);
					else
						result = getInterpolatedPrefixSums(right);
	
					if (left < 0)
						result -= (1.f - abs(left)) * uintBitsToFloat(scratch_shared[0u]);
					else
						result -= getInterpolatedPrefixSums(left);
	
					blurred[i][ch] = result/(2.f*RADIUS + 1.f);
				}
			}
		}
	}

	for (uint i = 0; i < VT; ++i)
		nbl_glsl_ext_Blur_setData(i, blurred[i]);
}
