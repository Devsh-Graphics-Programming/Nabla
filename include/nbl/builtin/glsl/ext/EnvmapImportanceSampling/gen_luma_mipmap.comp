#ifndef _NBL_GLSL_EXT_ENVMAP_SAMPLING_GEN_LUMA_INCLUDED_
#define _NBL_GLSL_EXT_ENVMAP_SAMPLING_GEN_LUMA_INCLUDED_

#include <nbl/builtin/glsl/ext/EnvmapImportanceSampling/parameters.glsl>
#include <nbl/builtin/glsl/math/functions.glsl>

layout(local_size_x = LUMA_MIP_MAP_GEN_WORKGROUP_DIM, local_size_y = LUMA_MIP_MAP_GEN_WORKGROUP_DIM) in;

layout(set = 0, binding = 0) uniform sampler2D envMap; // should be PoT
layout(set = 0, binding = 1, r32f) uniform image2D srcLuminance;
layout(set = 0, binding = 2, r32f) uniform image2D dstluminance;

layout(push_constant) uniform PushConstants
{
	LumaMipMapGenShaderData_t data;
} pc;

void main()
{
	const ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	
	const ivec2 envMapSize = textureSize(envMap, 0).xy;
	if (all(lessThan(pixelCoord,envMapSize)))
	{
		// Copy EnvMap to Last Luma MipMap Level
		{
			const ivec2 dstMipLevelSize = imageSize(dstluminance).xy;
			if(pc.data.calcLuma > 0)
			{
				vec3 envMapSample = texelFetch(envMap, pixelCoord, 0).rgb;
				// alpha is not 1.0 in all exr images but we need it to be 1 for correct calculations
				float luma = dot(pc.data.luminanceScales, vec4(envMapSample, 1.0f));
				luma *= sin(nbl_glsl_PI * (float(pixelCoord.y + 0.5f) / envMapSize.y));
				imageStore(srcLuminance, pixelCoord, vec4(luma));
			}
			else if (all(lessThan(pixelCoord,dstMipLevelSize)))
			{
				// just because the output is in range, doesn't mean 2x2 neighbourhood of the input will be
				// and using out of bounds unnormalized coordinates for non sampler image functions is UB
/* Proper way to do it, but the shader and code in the `ext` is too tightly coupled to refactor quickly!
				const vec2 gatherCoordinate = (vec2(pixelCoord)+vec2(0.5f))/vec2(dstMipLevelSize);
				const vec4 neighbourhood = textureGather(srcLuminance,gatherCoordinate);
				imageStore(dstluminance, pixelCoord, vec4(neighbourhood[0]+neighbourhood[1]+neighbourhood[2]+neighbourhood[3],0.f,0.f,0.f));
*/
				ivec2 gatherCoordinate = pixelCoord*2;
				
				const ivec2 srcMipLevelSize = imageSize(srcLuminance).xy;
				// assuming that `gatherCoordinate<srcMipLevelSize` which will be the case for PoT textures
				float luma = imageLoad(srcLuminance, gatherCoordinate + ivec2(0,0)).r;
				if (gatherCoordinate.x<srcMipLevelSize.x)
					luma += imageLoad(srcLuminance, gatherCoordinate + ivec2(1,0)).r;
				if (gatherCoordinate.y<srcMipLevelSize.y)
				{
					luma += imageLoad(srcLuminance, gatherCoordinate + ivec2(0,1)).r;
					if (gatherCoordinate.x<srcMipLevelSize.x)
						luma += imageLoad(srcLuminance, gatherCoordinate + ivec2(1,1)).r;
				}

				imageStore(dstluminance, pixelCoord, vec4(luma));
			}
		}
	}
}

#endif