#version 460 core

#include <nbl/builtin/glsl/macros.glsl>

#ifndef _NBL_GLSL_WORKGROUP_SIZE_
#define _NBL_GLSL_WORKGROUP_SIZE_ 256
#endif

#ifndef _NBL_GLSL_BLIT_OUT_CHANNEL_COUNT_
#error _NBL_GLSL_BLIT_OUT_CHANNEL_COUNT_ must be defined
#endif

#ifndef _NBL_GLSL_BLIT_DIM_COUNT_
#error _NBL_GLSL_BLIT_DIM_COUNT_ must be defined
#endif

#ifndef _NBL_GLSL_BLIT_OUT_IMAGE_FORMAT_
#error _NBL_GLSL_BLIT_OUT_IMAGE_FORMAT_ must be defined
#endif

#ifndef _NBL_GLSL_BLIT_SMEM_FLOAT_COUNT_
#error _NBL_GLSL_BLIT_SMEM_FLOAT_COUNT_ must be defined
#endif

#if NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 1)
	#define _NBL_GLSL_BLIT_IN_SAMPLER_TYPE_ sampler1DArray
	#ifdef _NBL_GLSL_BLIT_SOFTWARE_CODEC_
		#define _NBL_GLSL_BLIT_OUT_IMAGE_TYPE_ uimage1DArray
	#else
		#define _NBL_GLSL_BLIT_OUT_IMAGE_TYPE_ image1DArray
	#endif
#elif NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 2)
	#define _NBL_GLSL_BLIT_IN_SAMPLER_TYPE_ sampler2DArray
	#ifdef _NBL_GLSL_BLIT_SOFTWARE_CODEC_
		#define _NBL_GLSL_BLIT_OUT_IMAGE_TYPE_ uimage2DArray
	#else
		#define _NBL_GLSL_BLIT_OUT_IMAGE_TYPE_ image2DArray
	#endif
#elif NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 3)
	#define _NBL_GLSL_BLIT_IN_SAMPLER_TYPE_ sampler3D
	#ifdef _NBL_GLSL_BLIT_SOFTWARE_CODEC_
		#define _NBL_GLSL_BLIT_OUT_IMAGE_TYPE_ uimage3D
	#else
		#define _NBL_GLSL_BLIT_OUT_IMAGE_TYPE_ image3D
	#endif
#else
	#error _NBL_GLSL_BLIT_DIM_COUNT_ not supported
#endif

#ifndef _NBL_GLSL_BLIT_PIXEL_TYPE_DEFINED_
#define _NBL_GLSL_BLIT_PIXEL_TYPE_DEFINED_
struct nbl_glsl_blit_pixel_t
{
	vec4 data;
};
#endif

layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;

shared float nbl_glsl_blit_scratchShared[_NBL_GLSL_BLIT_OUT_CHANNEL_COUNT_][_NBL_GLSL_BLIT_SMEM_FLOAT_COUNT_];
#define _NBL_GLSL_SCRATCH_SHARED_DEFINED_ nbl_glsl_blit_scratchShared

#include <nbl/builtin/glsl/blit/parameters.glsl>
#include <nbl/builtin/glsl/blit/blit/descriptors.glsl>
#include <nbl/builtin/glsl/blit/blit/blit.glsl>

layout(push_constant) uniform Block
{
	nbl_glsl_blit_parameters_t params;
} pc;

#ifndef _NBL_GLSL_BLIT_GET_PARAMETERS_DEFINED_
nbl_glsl_blit_parameters_t nbl_glsl_blit_getParameters()
{
	return pc.params;
}
#define _NBL_GLSL_BLIT_GET_PARAMETERS_DEFINED_
#endif

#ifndef _NBL_GLSL_BLIT_GET_DATA_DEFINED_

#ifndef _NBL_GLSL_BLIT_IN_DESCRIPTOR_DEFINED_
#error _NBL_GLSL_BLIT_IN_DESCRIPTOR_DEFINED_ must be defined
#endif

nbl_glsl_blit_pixel_t nbl_glsl_blit_getData(in ivec3 coord)
{
	nbl_glsl_blit_pixel_t result;

#if NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 1)
	#define COORD coord.xy
#elif NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 2)
	#define COORD coord
#elif NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 3)
	#define COORD coord
#else
	#error _NBL_GLSL_BLIT_DIM_COUNT_ not supported
#endif

	result.data = texelFetch(_NBL_GLSL_BLIT_IN_DESCRIPTOR_DEFINED_, COORD, 0);
	return result;
#undef COORD
}

#define _NBL_GLSL_BLIT_GET_DATA_DEFINED_
#endif

#ifndef _NBL_GLSL_BLIT_SET_DATA_DEFINED_

#ifndef _NBL_GLSL_BLIT_DIM_COUNT_
#error _NBL_GLSL_BLIT_DIM_COUNT_ must be defined
#endif

#ifndef _NBL_GLSL_BLIT_OUT_DESCRIPTOR_DEFINED_
#error _NBL_GLSL_BLIT_OUT_DESCRIPTOR_DEFINED_ must be defined
#endif

void nbl_glsl_blit_setData(in nbl_glsl_blit_pixel_t value, in ivec3 coord)
{
#if NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 1)
	#define COORD coord.xy
#elif NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 2)
	#define COORD coord
#elif NBL_GLSL_EQUAL(_NBL_GLSL_BLIT_DIM_COUNT_, 3)
	#define COORD coord
#else
	#error _NBL_GLSL_BLIT_DIM_COUNT_ not supported
#endif

#ifdef _NBL_GLSL_BLIT_SOFTWARE_CODEC_
	imageStore(_NBL_GLSL_BLIT_OUT_DESCRIPTOR_DEFINED_, COORD, nbl_glsl_blit_formats_encode(value.data));
#else
	imageStore(_NBL_GLSL_BLIT_OUT_DESCRIPTOR_DEFINED_, COORD, value.data);
#endif

#undef COORD
}

#define _NBL_GLSL_BLIT_SET_DATA_DEFINED_
#endif

#ifndef _NBL_GLSL_BLIT_GET_CACHED_WEIGHTS_PREMULTIPLIED_DEFINED_

#ifndef _NBL_GLSL_BLIT_WEIGHTS_DESCRIPTOR_DEFINED_
#error _NBL_GLSL_BLIT_WEIGHTS_DESCRIPTOR_DEFINED_ must be defined
#endif

float nbl_glsl_blit_getCachedWeightsPremultiplied(in uvec3 lutCoord)
{
	const vec3 weight = vec3(_NBL_GLSL_BLIT_WEIGHTS_DESCRIPTOR_DEFINED_.data[lutCoord.x], _NBL_GLSL_BLIT_WEIGHTS_DESCRIPTOR_DEFINED_.data[lutCoord.y], _NBL_GLSL_BLIT_WEIGHTS_DESCRIPTOR_DEFINED_.data[lutCoord.z]);

	float result = 1.f;
	for (uint d = 0u; d < _NBL_GLSL_BLIT_DIM_COUNT_; ++d)
		result *= weight[d];

	return result;
}
#define _NBL_GLSL_BLIT_GET_CACHED_WEIGHTS_PREMULTIPLIED_DEFINED_
#endif

#ifndef _NBL_GLSL_BLIT_ADD_TO_HISTOGRAM_DEFINED_
void nbl_glsl_blit_addToHistogram(in uint bucketIndex, in uint layerIdx)
{
#ifdef _NBL_GLSL_BLIT_COVERAGE_SEMANTIC_
	#ifndef _NBL_GLSL_BLIT_ALPHA_HISTOGRAM_DESCRIPTOR_DEFINED_
		#error _NBL_GLSL_BLIT_ALPHA_HISTOGRAM_DESCRIPTOR_DEFINED_ must be defined
	#endif

	atomicAdd(_NBL_GLSL_BLIT_ALPHA_HISTOGRAM_DESCRIPTOR_DEFINED_.data[layerIdx].histogram[bucketIndex], 1u);
#endif
}
#define _NBL_GLSL_BLIT_ADD_TO_HISTOGRAM_DEFINED_
#endif

void main()
{
	nbl_glsl_blit_main();
}
