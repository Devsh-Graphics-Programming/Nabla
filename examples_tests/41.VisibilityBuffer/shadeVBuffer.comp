//

#include "common.glsl"
layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 2, binding = 1, std430) readonly buffer IndexBuffer
{
    Packed_uvec3_t indexBuffer[];
};

struct MaterialParams
{
    vec3 Ka;
    vec3 Kd;
    vec3 Ks;
    vec3 Ke;
    uvec2 map_Ka_data;
    uvec2 map_Kd_data;
    uvec2 map_Ks_data;
    uvec2 map_Ns_data;
    uvec2 map_d_data;
    uvec2 map_bump_data;
    float Ns;
    float d;
    float Ni;
    uint extra; //flags copied from MTL metadata
};
layout(set = 2, binding = 2, std430) readonly buffer MaterialBuffer
{
    MaterialParams materialData[];
};

#include <nbl/builtin/glsl/virtual_texturing/extensions.glsl>
#include <nbl/builtin/glsl/virtual_texturing/descriptors.glsl>
layout (set = 2, binding = 3, std430) restrict readonly buffer PrecomputedStuffSSBO
{
    uint pgtab_sz_log2;
    float vtex_sz_rcp;
    float phys_pg_tex_sz_rcp[_NBL_VT_MAX_PAGE_TABLE_LAYERS];
    uint layer_to_sampler_ix[_NBL_VT_MAX_PAGE_TABLE_LAYERS];
} precomputed;

layout(set = 3, binding = 0) sampler2D vBuffer;
layout(set = 3, binding = 1) image2D frameBuffer;

#include <nbl/builtin/glsl/loader/mtl/common.glsl>
uint drawGUID;
nbl_glsl_MTLMaterialParameters nbl_glsl_getMaterialParameters() // this function is for MTL's shader only
{
    MaterialParams params = materialData[drawGUID];

    nbl_glsl_MTLMaterialParameters mtl_params;
    mtl_params.Ka = params.Ka;
    mtl_params.Kd = params.Kd;
    mtl_params.Ks = params.Ks;
    mtl_params.Ke = params.Ke;
    mtl_params.Ns = params.Ns;
    mtl_params.d = params.d;
    mtl_params.Ni = params.Ni;
    mtl_params.extra = params.extra;
    return mtl_params;
}
#define _NBL_FRAG_GET_MATERIAL_PARAMETERS_FUNCTION_DEFINED_


uint nbl_glsl_VT_layer2pid(in uint layer)
{
    return precomputed.layer_to_sampler_ix[layer];
}
uint nbl_glsl_VT_getPgTabSzLog2()
{
    return precomputed.pgtab_sz_log2;
}
float nbl_glsl_VT_getPhysPgTexSzRcp(in uint layer)
{
    return precomputed.phys_pg_tex_sz_rcp[layer];
}
float nbl_glsl_VT_getVTexSzRcp()
{
    return precomputed.vtex_sz_rcp;
}
#define _NBL_USER_PROVIDED_VIRTUAL_TEXTURING_FUNCTIONS_


vec4 nbl_glsl_vTextureGrad


vec4 nbl_sample_Ka(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Ka_data, uv, dUV); }

vec4 nbl_sample_Kd(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Kd_data, uv, dUV); }

vec4 nbl_sample_Ks(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Ks_data, uv, dUV); }

vec4 nbl_sample_Ns(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Ns_data, uv, dUV); }

vec4 nbl_sample_d(in vec2 uv, in mat2 dUV)    { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_d_data, uv, dUV); }

vec4 nbl_sample_bump(in vec2 uv, in mat2 dUV) { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_bump_data, uv, dUV); }



mat2x3 dPdBary;
mat2x3 nbl_glsl_perturbNormal_dPdSomething()
{
    return dPdBary;
}
mat2 dUVdBary;
mat2 nbl_glsl_perturbNormal_dUVdSomething()
{
    return dUVdBary;
}
#define _NBL_BUILTIN_GLSL_BUMP_MAPPING_DERIVATIVES_DECLARED_

void main()
{
    // TODO: out of bounds check and return
    const ivec2 fragCoord = ivec2(gl_GlobalInvocationID);
    uvec4 triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2 = texelFetch(vBuffer,fragCoord,0);

    drawGUID = 0xdeadbeefu;
    const uint triangleID = 0xdeadbeefu;
    const vec2 bary = unpackUnorm2x16(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[1]);
    const mat2 dBary = mat2(
        unpackHalf2x16(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[2]),
        unpackHalf2x16(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[3])
    );

    const Packed_uvec3_t vertices; // TODO: = indexBuffer[triangleID+virtualAttribTable.baseVertex[drawGUID]];

    vec3 pos,normal;
    vec2 uv;
    mat2 dUVdScreen;
    {
        vec3 positions[3];
        vec2 uvs[3];
        // wrap this up into a template macro?
        for (int i=0; i<3; i++)
        {
            positions[i] = nbl_glsl_fetchVtxPos(vertices[i],drawGUID);
            uvs[i] = nbl_glsl_fetchVtxUV(vertices[i],drawGUID);
        }

        // maybe could wrap this up into a function
        dPdBary[0] = positions[1]-positions[0];
        dPdBary[1] = positions[2]-positions[0];
        pos = dPdBary*bary+positions[0];

        dUVdBary[0] = uvs[1]-uvs[0];
        dUVdBary[1] = uvs[2]-uvs[0];
        uv = dUVdBary*bary+uvs[0];

        dUVdScreen = nbl_glsl_applyChainRule2D(dUVdBary,dBary);

        const float lastBary = 1.f-bary.x-bay.y;


        normal = nbl_glsl_fetchVtxNormal(vertices[0],drawGUID)*bary.x;
        normal += nbl_glsl_fetchVtxNormal(vertices[1],drawGUID)*bary.y;
        normal += nbl_glsl_fetchVtxNormal(vertices[2],drawGUID)*lastBary;
    }

    vec4 color; // TODO: shading

    imageStore(frameBuffer,fragCoord,color);
}