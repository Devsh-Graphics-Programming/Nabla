#version 430 core

#define _NBL_GLSL_WORKGROUP_SIZE_ 256

// Todo: DRY!!
#define COUNT 4096
#define RADIUS 1.73f

// This would probably be a push constant
#define VT 16

layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_, local_size_y = 1) in;

#if 0
layout (set = 0, binding = 0) uniform sampler2D in_image;

layout (set = 0, binding = 1, rgba16f) writeonly uniform image2D out_image;
#endif

layout (set = 0, binding = 0) readonly buffer in_buffer
{
	float in_values[];
};

layout (set = 0, binding = 1) writeonly buffer out_buffer
{
	float out_values[];
};

#include <nbl/builtin/glsl/workgroup/shared_arithmetic.glsl>

#ifdef _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_
	#if NBL_GLSL_EVAL(_NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_) < NBL_GLSL_EVAL(_NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_)
		#error "Not enough shared memory declared"
	#endif
#else
	#if COUNT < _NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_
		#define _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_ _NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_
	#else
		#define _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_ COUNT
	#endif

    #define _NBL_GLSL_SCRATCH_SHARED_DEFINED_ nbl_glsl_ext_Blur_scratchShared
    #define _NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_ _NBL_GLSL_EXT_BLUR_SHARED_SIZE_NEEDED_
	shared uint _NBL_GLSL_SCRATCH_SHARED_DEFINED_[_NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_];
#endif

#define _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_ ((_NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_-1)/_NBL_GLSL_WORKGROUP_SIZE_+1)

#if _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_ > VT
  #define _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_ VT
#else
  // #define _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_ _NBL_GLSL_EXT_BLUR_IMPL_LOCAL_SPILLAGE_ 
  #define _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_ VT
#endif

#include <nbl/builtin/glsl/workgroup/arithmetic.glsl>
#include <nbl/builtin/glsl/workgroup/ballot.glsl>

// Convenience thing
#define scratch_shared _NBL_GLSL_SCRATCH_SHARED_DEFINED_

// Note: This function depends on `scratch_shared` to be properly initialized with inclusive prefix sums
float getInterpolatedPrefixSums(float idx)
{
	uint floored = uint(floor(idx));
	return mix(uintBitsToFloat(scratch_shared[floored]), uintBitsToFloat(scratch_shared[floored + 1u]), fract(idx));
}

float getPaddedData(in uint idx)
{
	float data = 0.f;
	if (idx < COUNT)
		data = in_values[idx];

	return data;
}

void main()
{

	{
		float previous_block_sum = 0.f;

		int arithmetic_shared_size = _NBL_GLSL_WORKGROUP_ARITHMETIC_SHARED_SIZE_NEEDED_;
		int ballot_shared_size = _NBL_GLSL_WORKGROUP_BALLOT_SHARED_SIZE_NEEDED_;

		float spill[_NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_];
		for (uint i = 0u; i < _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; ++i)
		{
		    uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
			float data = getPaddedData(idx);

		    spill[i] = nbl_glsl_workgroupInclusiveAdd(data) + previous_block_sum;
		    previous_block_sum = nbl_glsl_workgroupBroadcast(spill[i], _NBL_GLSL_WORKGROUP_SIZE_ - 1u);
		}

		for (uint i = _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; i < VT; ++i)
		{
		    uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
		    float data = getPaddedData(idx);
		    
		    float scan_result = nbl_glsl_workgroupInclusiveAdd(data) + previous_block_sum;
		    previous_block_sum = nbl_glsl_workgroupBroadcast(scan_result,  _NBL_GLSL_WORKGROUP_SIZE_ - 1u);

		    scratch_shared[idx] = floatBitsToUint(scan_result);
		}

		for (uint i = 0u; i < _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; ++i)
		    scratch_shared[(i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex] = floatBitsToUint(spill[i]);
		barrier();
	}

#if 0

	float blurred[VT];
	for (uint i = 0; i < VT; ++i)
	{
		uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
		if (idx < COUNT)
		{
			float left = float(idx) - RADIUS - 1.f;
			float right = float(idx) + RADIUS;

			const uint last = COUNT - 1u;

			float result;
			if (right > last)
				result = (right - float(last)) * (uintBitsToFloat(scratch_shared[last]) - uintBitsToFloat(scratch_shared[last - 1u])) + uintBitsToFloat(scratch_shared[last]);
			else
				result = getInterpolatedPrefixSums(right);

			if (left < 0)
				result -= (1.f - abs(left)) * uintBitsToFloat(scratch_shared[0u]);
			else
				result -= getInterpolatedPrefixSums(left);

			blurred[i] = result/(2.f*RADIUS + 1.f);
		}
	}

	{
		float previous_block_sum = 0.f;

		// The things you want to prefix sum now are not in shared memory but thread private memory, more specifically
		// they are in `blurred`. Each thread has VT elements in `blurred`.

		float spill[_NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_];
		for (uint i = 0u; i < _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; ++i)
		{
		    uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
			float data = blurred[i];

		    spill[i] = nbl_glsl_workgroupInclusiveAdd(data) + previous_block_sum;
		    previous_block_sum = nbl_glsl_workgroupBroadcast(spill[i], _NBL_GLSL_WORKGROUP_SIZE_ - 1u);
		}

		for (uint i = _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; i < VT; ++i)
		{
		    uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
		    float data = blurred[i];
		    
		    float scan_result = nbl_glsl_workgroupInclusiveAdd(data) + previous_block_sum;
		    previous_block_sum = nbl_glsl_workgroupBroadcast(scan_result,  _NBL_GLSL_WORKGROUP_SIZE_ - 1u);

		    scratch_shared[idx] = floatBitsToUint(scan_result);
		}

		for (uint i = 0u; i < _NBL_GLSL_EXT_BLUR_LOCAL_SPILLAGE_; ++i)
		    scratch_shared[(i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex] = floatBitsToUint(spill[i]);
		barrier();
	}
#endif

	// Temporary
	for (uint i = 0; i < VT; ++i)
	{
		uint idx = (i * _NBL_GLSL_WORKGROUP_SIZE_) + gl_LocalInvocationIndex;
		if (idx < COUNT)
			out_values[idx] = uintBitsToFloat(scratch_shared[idx]); // blurred[i]; 
	}
}