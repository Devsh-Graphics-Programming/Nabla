// Copyright (C) 2018-2020 - DevSH Graphics Programming Sp. z O.O.
// This file is part of the "Nabla Engine".
// For conditions of distribution and use, see copyright notice in nabla.h

#version 450

#pragma shader_stage(compute)

layout (local_size_x = 256, local_size_y = 1) in;

layout (push_constant) uniform pushConstants
{
	uvec2 imgSize;
	uint pointCount;
	mat4 mvp;
} u_pushConstants;
layout (set = 0, binding = 0, r32ui) uniform coherent uimage2D outImage;
layout (set = 0, binding = 1, std430) readonly buffer pointCloud {
	vec3 position[];
} u_pointCloud;

void main()
{
	if (gl_GlobalInvocationID.x >= u_pushConstants.pointCount) 
	{
		return;
	}
	vec3 pointPosition = u_pointCloud.position[gl_GlobalInvocationID.x];
	vec4 transformed = u_pushConstants.mvp * vec4(pointPosition, 1.0);

	// Behind the camera
	if (transformed.z < 0.0) 
	{
		return;
	}

	vec3 ndc = transformed.xyz / vec3(transformed.w);
	vec2 uv = (ndc.xy + 1.0) * 0.5;
	const ivec2 size = ivec2(5, 5);
	const vec2 halfTexelSize = (vec2(size) * 0.5) / vec2(u_pushConstants.imgSize);
	// AABB for the point: uv - halfTexelSize to uv + halfTexelSize

	ivec2 offset = ivec2((uv - halfTexelSize) * vec2(u_pushConstants.imgSize));
	ivec2 curPixel = ivec2(0);
	// Flattened iteration over the AABB
	// TODO make the points circles
	
	// If the Y has gone outside the AABB, it has no more pixels
	while (curPixel.y > size.y) {
		ivec2 coords = offset + curPixel;
		if (all(greaterThanEqual(coords, ivec2(0))) && all(lessThan(coords, ivec2(u_pushConstants.imgSize))))
		{
			// Write out depth
			imageAtomicMax(outImage, coords, floatBitsToUint(ndc.z));
		}

		curPixel.x += 1;
		// If curPixel.x == size.x, increments Y by 1 and reset X to 0
		curPixel.y += curPixel.x / size.x;
		curPixel.x = curPixel.x % size.x;
	}
}