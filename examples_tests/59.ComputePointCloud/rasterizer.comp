// Copyright (C) 2018-2020 - DevSH Graphics Programming Sp. z O.O.
// This file is part of the "Nabla Engine".
// For conditions of distribution and use, see copyright notice in nabla.h

#version 450

#pragma shader_stage(compute)

#include "common.h"

layout (local_size_x = 256, local_size_y = 1) in;

layout (push_constant) uniform pushConstants
{
	layout(row_major) RasterizerPushConstants c;
} u_pushConstants;
layout (set = 0, binding = 0, rg32ui) uniform coherent uimage2D outImage;
layout (set = 0, binding = 1, r32ui) uniform coherent uimage2D spinLock;

struct WorldPosition {
	float x, y, z;
};

layout (set = 0, binding = 2, std430) readonly buffer pointCloud {
	WorldPosition position[];
} u_pointCloud;

struct DebugOutputPoint {
	vec4 transformed;
	uvec4 cameraCull;
	vec3 ndc;
	uint pad;
	vec2 uv;
	vec2 pad2;
	ivec2 coords;
	vec2 pad3;
};

void writeOut(ivec2 coords, float pointDepth, uint pointId) {
	float previousDepth = uintBitsToFloat(imageLoad(outImage, coords).x);
	if (pointDepth > previousDepth) {
		imageStore(outImage, coords, uvec4(floatBitsToUint(pointDepth), pointId, 0, 0));
	}
}

#include <nbl/builtin/glsl/utils/transform.glsl>

mat4 spvWorkaroundRowMajor(mat4 wrap) { return wrap; }

void main()
{
	uint localThread = gl_GlobalInvocationID.x;
	// Persistent threads
	// e.g. thread 1 starts with 1, then goes for totalThreads + 1 and so on until there are no more points for it
	for (uint virtInvoc = localThread; virtInvoc < u_pushConstants.c.pointCount; virtInvoc += u_pushConstants.c.totalThreads) {
		WorldPosition pointPos = u_pointCloud.position[virtInvoc];
		vec3 pointPos3 = vec3(pointPos.x, pointPos.y, pointPos.z);
		vec4 transformed = nbl_glsl_pseudoMul4x4with3x1(spvWorkaroundRowMajor(u_pushConstants.c.mvp), pointPos3);

		// Behind the camera
		// XOR of the sign bits (if only one of Z or W is negative, cull it)
		if ((floatBitsToUint(transformed.z) ^ floatBitsToUint(transformed.w)) >> 31 == 1) 
		{
			continue;
		}

		vec3 ndc = transformed.xyz / vec3(transformed.w);

		if (ndc.z > 1.0) 
		{
			continue;
		}
		ndc.z = 1.0 - ndc.z;

		vec2 uv = (ndc.xy + 1.0) * 0.5;
		const ivec2 size = ivec2(5, 5);

		ivec2 coords = ivec2(uv * vec2(u_pushConstants.c.imgSize));
		
		if (all(greaterThanEqual(coords, ivec2(0))) && all(lessThan(coords, ivec2(u_pushConstants.c.imgSize))))
		{
			// Write out depth
			// (Spinlock implementation)
			// TODO 64 bit atomic implementation
			for (bool done = false; !done;) {
				if (imageAtomicExchange(spinLock, coords, 1u) == 0u) {
					memoryBarrierImage();
					writeOut(coords, ndc.z, virtInvoc);
					imageStore(spinLock, coords, uvec4(0u));
					memoryBarrierImage();
					done = true;
				}
			}
		}
	}
}