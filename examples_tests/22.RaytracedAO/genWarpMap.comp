#version 430 core

#include "warpCommon.h"
#include <nbl/builtin/glsl/math/functions.glsl>

layout(local_size_x = WARP_MAP_GEN_WORKGROUP_DIM, local_size_y = WARP_MAP_GEN_WORKGROUP_DIM) in;

layout(set = 0, binding = 0) uniform sampler2D luminance[MAX_LUMINANCE_LEVELS];
// layout(set = 0, binding = 1, r32ui) uniform image2D warpMap;
layout(set = 0, binding = 1, rg16f) uniform image2D warpMap;

layout(push_constant) uniform PushConstants
{
	WarpMapGenShaderData_t data;
} pc;

void main()
{
	const ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 warpMapSize = imageSize(warpMap).xy;
	const ivec2 lastWarpMapPixel = warpMapSize-ivec2(1);

	if (all(lessThan(pixelCoord,warpMapSize)))
	{
		
#if 0
		vec2 xi = vec2(pixelCoord)/vec2(lastWarpMapPixel);
		imageStore(warpMap,pixelCoord,vec4(xi, 0, 0));
#else
		// Corner Sampling, this is why it was important to have the envmap be PoT-1, so you can have xi both 0% and 100%
		vec2 xi = vec2(pixelCoord)/vec2(lastWarpMapPixel);
		ivec2 p = ivec2(0, 0);

		// WARP
		// (skip 0 which is 1x1 and useless in warping)
		for(int i = 1; i < pc.data.lumaMipCount; ++i)
		{
			ivec2 luminanceMipSize = textureSize(luminance[i], 0).xy;
			if(i > 0)
			{
				ivec2 preLuminanceMipSize = textureSize(luminance[i-1], 0).xy;
				if(luminanceMipSize.x > preLuminanceMipSize.x)
					p.x *= 2;
				if(luminanceMipSize.y > preLuminanceMipSize.y)
					p.y *= 2;
			}

			vec4 values = vec4(0);
			values[0] = texelFetch(luminance[i], p + ivec2(0, 1), 0).r;
			values[1] = texelFetch(luminance[i], p + ivec2(1, 1), 0).r;
			values[2] = texelFetch(luminance[i], p + ivec2(1, 0), 0).r;
			values[3] = texelFetch(luminance[i], p + ivec2(0, 0), 0).r;

			float wx_0 = values[3] + values[0]; // Left Weight (0,0) + (0,1) 
			float wx_1 = values[2] + values[1]; // Right Weight (1,0) + (1,1)
			float wy_0 = 0.0f;
			float wy_1 = 0.0f;

			float leftProb = 1.0f/(1.0f+wx_1/wx_0);
			float dummy = 0.0f;
			if(nbl_glsl_partitionRandVariable(leftProb, xi.x, dummy))
			{
				// Picked Right
				p.x += 1;
				wy_0 = values[2]; // (1, 0)
				wy_1 = values[1]; // (1, 1)
			}
			else
			{
				// Picked Left
				wy_0 = values[3]; // (0, 0)
				wy_1 = values[0]; // (0, 1)
			}
			
			float upProb = 1.0f/(1.0f+wy_1/wy_0);
			if(nbl_glsl_partitionRandVariable(upProb, xi.y, dummy))
			{
				// Picked Down
				p.y += 1;
			}
		}

		const vec2 directionUV = vec2(p.x,p.y)/vec2(lastWarpMapPixel);
		// imageStore(warpMap,pixelCoord, vec4(packUnorm2x16(directionUV)));
		imageStore(warpMap,pixelCoord,vec4(directionUV, 0, 0));
#endif
	}

}