#version 430 core

#include "warpCommon.h"
#include <nbl/builtin/glsl/math/functions.glsl>

layout(local_size_x = WARP_MAP_GEN_WORKGROUP_DIM, local_size_y = WARP_MAP_GEN_WORKGROUP_DIM) in;

#define MAX_LUMINANCE_LEVELS 13

layout(set = 0, binding = 0) uniform sampler2D luminance[MAX_LUMINANCE_LEVELS];
// layout(set = 0, binding = 1, r32ui) uniform image2D warpMap;
layout(set = 0, binding = 1, rg16f) uniform image2D warpMap;

layout(push_constant) uniform PushConstants
{
	WarpMapGenShaderData_t data;
} pc;

void main()
{
	const ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 warpMapSize = imageSize(warpMap).xy;
	const ivec2 lastWarpMapPixel = warpMapSize-ivec2(1);

	if (all(lessThan(pixelCoord,warpMapSize)))
	{
		// Corner Sampling, this is why it was important to have the envmap be PoT-1, so you can have xi both 0% and 100%
		vec2 xi = vec2(pixelCoord)/vec2(lastWarpMapPixel);
		ivec2 p = ivec2(0, 0);

		// WARP
		// (skip 0 which is 1x1 and useless in warping)
		for(int i = 1; i < pc.data.lumaMipCount; ++i)
		{
			ivec2 luminanceMipSize = textureSize(luminance[i], 0).xy;
			if(i > 0)
			{
				ivec2 preLuminanceMipSize = textureSize(luminance[i-1], 0).xy;
				if(luminanceMipSize.x > preLuminanceMipSize.x)
					p.x *= 2;
				if(luminanceMipSize.y > preLuminanceMipSize.y)
					p.y *= 2;
			}

			vec4 values = textureGather(luminance[i], (p + ivec2(1,1))/luminanceMipSize); // 0_1, 1_1, 1_0, 0_0
			
			float wx_0 = values[3] + values[0]; // Left Weight (0,0) + (0,1) 
			float wx_1 = values[2] + values[1]; // Right Weight (1,0) + (1,1)
			float wy_0 = 0.0f;
			float wy_1 = 0.0f;

			float leftProb = 1.0f/(1+wx_1/wx_0);
			float dummy = 0.0f;
			if(nbl_glsl_partitionRandVariable(leftProb, xi.x, dummy))
			{
				// Picked Right
				p.x += 1;
				wy_0 = values[2]; // (1, 0)
				wy_1 = values[1]; // (1, 1)
			}
			else
			{
				// Picked Left
				wy_0 = values[3]; // (0, 0)
				wy_1 = values[0]; // (0, 1)
			}
			
			float upProb = 1.0f/(1+wy_1/wy_0);
			if(nbl_glsl_partitionRandVariable(upProb, xi.y, dummy))
			{
				// Picked Down
				p.y += 1;
			}
		}

		const vec2 directionUV = vec2(p.x,p.y)/vec2(lastWarpMapPixel);
		// imageStore(warpMap,pixelCoord, vec4(packUnorm2x16(directionUV)));
		imageStore(warpMap,pixelCoord,vec4(directionUV.x, directionUV.y, 0, 0));
	}

}