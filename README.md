# Nabla

test

<div align="center">
  <br/>
  <a href="https://github.com/Devsh-Graphics-Programming/Nabla/blob/readme/nabla-glow.svg">
    <img alt="Click to see the source" height="200" src="nabla-glow.svg" width="200" />
  </a>
  <br/>
</div>

< TODO: short desc >

# Table of Contents

< TODO >

# Showcase

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean eu odio gravida, tristique quam quis, dignissim purus. Sed sed neque facilisis, venenatis odio in, dignissim risus. Nulla facilisi. Aliquam dictum volutpat ligula. Quisque vehicula condimentum bibendum. Morbi posuere, libero ac porttitor molestie, sem enim molestie sapien, at consectetur metus lacus nec justo. Sed sollicitudin nisl ut tellus posuere pharetra. Phasellus in rutrum elit. Nunc dui dui, ultricies eu nunc in, dictum gravida eros. Integer fermentum in turpis non ultricies. Cras sit amet sagittis sapien. Integer dignissim mauris ac magna dapibus, non ultrices risus rhoncus. Sed gravida hendrerit mattis. Pellentesque a congue massa. Nullam in cursus libero. Ut ac tristique mauris.

TODO aspect ratio + images alignment + more more images

<center>
  <table style="width: 100%; border-collapse: collapse; vertical-align:top;">
    <!-- row 1 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/a14ba3d6-338b-4814-b67a-1d680766b5b6" alt="Ray Tracing" style="width:100%; height:auto;">
          <img src="https://github.com/user-attachments/assets/241fdeaf-92c4-4f6e-9a80-73307b4948c6" alt="Ray Tracing" style="width:100%; height:auto;">
        <div align="center">
          <a href="TODO" target="_blank">Ray Tracing</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/07f71a81-1f9f-4874-99ab-ec6b9ce6c598" alt="Emulated shaderFloat64" style="width:100%; height:auto;">
        <div align="center">
          <a href="TODO" target="_blank">Emulated shaderFloat64</a>
        </div>
      </td>
    </tr>
    <!-- row 2 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:bottom; vertical-align: top; valign:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/99831ff2-61af-4c08-9c44-6fd0d04878cb" alt="MSDF Hatches" style="width:100%; height:auto; vertical-align:top; align:top;">
          <img src="https://github.com/user-attachments/assets/095764a5-a07c-499b-a1fb-d1fcd98102f9" alt="MSDF Hatches 2" style="width:100%; height:auto; vertical-align:top; align:top;">
        <div align="center">
          <a href="TODO" target="_blank">MSDF Hatches</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/7941f9f0-876e-4cd8-a6e5-3c403e339c59" alt="TODODOO" style="width:100%; height:auto;">
          <img src="https://github.com/user-attachments/assets/89401139-5f06-4aaf-a081-ed540976660a" alt="TODODOO 2" style="width:100%; height:auto;">
          <img src="https://github.com/user-attachments/assets/d2d56b1e-8a21-4bcd-aa14-8e3e86ec22ba" alt="TODODOO 3" style="width:100%; height:auto;">
        <div align="center">
           <a href="TODO" target="_blank">TODO</a>
        </div>
      </td>
    </tr>
    <!-- row 3 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:bottom; vertical-align: top; valign:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/c399f07f-50ec-4fcd-8914-0433adcd6a35" alt="SDF function manipulator" style="width:100%; height:auto; vertical-align:top; align:top;">
        <div align="center">
          <a href="TODO" target="_blank">SDF function manipulator</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/b7705a3a-ddba-466e-95f0-125458f00349" alt="Fluid 3D" style="width:100%; height:auto;">
        <div align="center">
           <a href="TODO" target="_blank">Fluid 3D</a>
        </div>
      </td>
    </tr>
    <!-- row 4 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:bottom; vertical-align: top; valign:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/124e9de1-5e59-444e-8c14-b536537cda9e" alt="SDF function manipulator" style="width:100%; height:auto; vertical-align:top; align:top;">
        <div align="center">
          <a href="TODO" target="_blank">Volume Reconstuction from Point Clouds</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/86452841-556b-43ed-ad95-ef45452b51d5" alt="ImGUI render backend and extensions" style="width:100%; height:auto;">
        <div align="center">
           <a href="TODO" target="_blank">ImGUI render backend & extensions</a>
        </div>
      </td>
    </tr>
  </table>
</center>

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean eu odio gravida, tristique quam quis, dignissim purus. Sed sed neque facilisis, venenatis odio in, dignissim risus. Nulla facilisi. Aliquam dictum volutpat ligula. Quisque vehicula condimentum bibendum. Morbi posuere, libero ac porttitor molestie, sem enim molestie sapien, at consectetur metus lacus nec justo. Sed sollicitudin nisl ut tellus posuere pharetra. Phasellus in rutrum elit. Nunc dui dui, ultricies eu nunc in, dictum gravida eros. Integer fermentum in turpis non ultricies. Cras sit amet sagittis sapien. Integer dignissim mauris ac magna dapibus, non ultrices risus rhoncus. Sed gravida hendrerit mattis. Pellentesque a congue massa. Nullam in cursus libero. Ut ac tristique mauris.


# Features

### 🧩 **The Nabla Core Profile**

Nabla exposes [a curated set of Vulkan extensions and features](https://github.com/Devsh-Graphics-Programming/Nabla/blob/master/src/nbl/video/vulkan/profiles/NablaCore.json) compatible across the GPUs we aim to support on Windows, Linux, (coming soon MacOS, iOS as well as Android)

Vulkan evolves fast—just when you think you've figured out [sync](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples-(Legacy-synchronization-APIs)), you realize there's [sync2](https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_synchronization2.html). Keeping up with new extensions, best practices, and hardware quirks is exhausting.
Instead of digging through [gpuinfo.org](gpuinfo.org) or [Vulkan specs](https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html), Nabla gives you a well-thought-out set of extensions—so you can focus on what you want to achieve, not get stuck in an eternal loop of:
  - mastering a feature
  - finding out about a new feature
  - assesing whether obsoletes or just adds the one you've just mastered
  - working if the feature is ubiquitous on the devices you target
  - rewriting what you've just polished

### 🧩 **Physical Device Selection and Filteration**

Nabla allows you to select the best GPU for your compute or graphics workload.

```c++
void filterDevices(core::set<video::IPhysicalDevice*>& physicalDevices)
{
  nbl::video::SPhysicalDeviceFilter deviceFilter = {};
  deviceFilter.minApiVersion = { 1,3,0 };
  deviceFilter.minConformanceVersion = {1,3,0,0};
  deviceFilter.requiredFeatures.rayQuery = true;
  deviceFilter(physicalDevices);
}
```

### 🧩 **SPIR-V and Vulkan as First-Class Citizens**

Nabla treats **SPIR-V** and **Vulkan** as the preferred, reference standard—everything else is built around them, with all other backends adapting to them.

### 🧩 **Integration of Renderdoc**

Built-in support for capturing frames and debugging with [Renderdoc](https://renderdoc.org/).
 This is how one debugs headless or async GPU workloads that are not directly involved in producing a swapchain frame to be captured by Renderdoc.

```c++
const IQueue::SSubmitInfo submitInfo = {
    .waitSemaphores = {},
    .commandBuffers = {&cmdbufInfo,1},
    .signalSemaphores = {&signalInfo,1}
};
m_api->startCapture(); // Start Renderdoc Capture
queue->submit({&submitInfo,1});
m_api->endCapture(); // End Renderdoc Capture
```

### 🧩 **Nabla Event Handler: Seamless GPU-CPU Synchronization**

Nabla Event Handler's extensive usage of [Timeline Semaphores](https://www.khronos.org/blog/vulkan-timeline-semaphores) enables CPU Callbacks on GPU conditions.

You can enqueue callbacks that trigger upon submission completion (workload finish), enabling amongst others, async readback of submission side effects, or deallocating an allocation after a workload is finished.

```c++
// This doesn't actually free the memory from the pool, the memory is queued up to be freed only after the `scratchSemaphore` reaches a value a future submit will signal
memory_pool->deallocate(&offset,&size,nextSubmit.getFutureScratchSemaphore());
```

### 🧩 **GPU Object Lifecycle Tracking**

Nabla uses [reference counting](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/core/decl/smart_refctd_ptr.h#L22) to track the lifecycle of GPU objects. Descriptor sets and command buffers are responsible for maintaining reference counts on the resources (e.g., buffers, textures) they use. The queue itself also tracks command buffers, ensuring that objects remain alive as long as they are pending execution. This system guarantees the correct order of deletion and makes it difficult for GPU objects to go out of scope and be destroyed before the GPU has finished using them.

### 🧩 **HLSL2021 Standard Template Library**

- 🔄 Reusable: Unified single-source C++/HLSL libraries eliminate code duplication with reimplementation of STL's `type_traits`, `limits`, `functional`, `tgmath`, etc.

- 🐞 Shader Logic, CPU-Tested: A subset of HLSL compiles as both C++ and SPIR-V, enabling CPU-side debugging of GPU logic, ensuring correctness in complex tasks like FFT, Prefix Sum, etc. (See our examples: [1. BxDF Unit Test](https://github.com/Devsh-Graphics-Programming/Nabla-Examples-and-Tests/blob/d7f7a87fa08a56a16cd1bcc7d4d9fd48fc8c278c/66_HLSLBxDFTests/app_resources/tests.hlsl#L436), [2. Math Funcs Unit Test](https://github.com/Devsh-Graphics-Programming/Nabla-Examples-and-Tests/blob/fd92730f0f5c8a120782c928309cb10e776c25db/22_CppCompat/main.cpp#L407))

- 🔮 Future-Proof: C++20 [concepts](https://en.cppreference.com/w/cpp/language/constraints) in HLSL enable safe and documented polymorphism.

- 🧠 Insane: Boost Preprocessor and Template Metaprogramming in HLSL!

- 🛠️ Real-World Problem Solvers: The library offers GPU-optimized solutions for tasks like Prefix Sum, Binary Search, FFT, Global Sort, and even emulated `shaderFloat64` when native GPU support is unavailable!

🎤 Talks from us:
 - [Vulkanised 2024: Beyond SPIR-V: Single Source C++ and Shader Programming](https://www.youtube.com/watch?v=JCJ35dlZJb4)
 - [Vulkanised 2023: HLSL202x like its C++, building an `std::` like Library]()

### 🧩 **Full Embrace of [Buffer Device Address]() and [Descriptor Indexing]()**

By utilizing Buffer Device Addresses (BDAs), Nabla enables more direct access to memory through 64-bit GPU virtual addresses. Synergized with Descriptor Indexing, this approach enhances flexibility by enabling more dynamic, scalable resource binding without relying on traditional descriptor sets.

### 🧩 **Minimally Invasive Design**

No Singletons, No Main Thread—Nabla allows multiple instances of every object (including Vulkan devices) without assuming a main thread or thread-local contexts. Thread-agnostic by design, it avoids global state and explicitly passes contexts for easy multithreading.

Nabla's minimally invasive and flexible design with api handle acquisitions and multi-window support make it ideal for custom rendering setups and low-level GPU programming without unnecessary constraints such as assuming a main thread or a single window.

Even Win32 windowing is wrapped for use across multiple threads, breaking free traditional single-thread limitations.

This allows simpler porting of legacy OpenGL and DirectX applications.

<p align="center">
  <div style="display: flex; justify-content: center; gap: 10px;">
    <img src="https://github.com/user-attachments/assets/1add9cbd-fabc-4e97-b4a1-373ccefa3d8a" alt="GDI 1" style="width: 30%; height: auto;">
    <img src="https://github.com/user-attachments/assets/97efeb67-d78c-4010-a0a2-198958b3deeb" alt="GDI 2" style="width: 30%; height: auto;">
    <img src="https://github.com/user-attachments/assets/82009094-81e5-4146-8f1a-5bac7e13f722" alt="GDI 3" style="width: 30%; height: auto;">
  </div>
</p>

### 🧩 **Designed for Interoperation**
Nabla is built with interoperation in mind, supporting memory export and import between different compute and graphics APIs.

### 🧩 **Cancellable Future based Async I/O**

File I/O is fully asynchronous, using [nbl::system::future_t](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/system/ISystem.h#L26), a cancellable MPSC circular buffer-based future implementation.

Requests start in a **PENDING** state and can be invalidated before execution if needed. This enables efficient async file reads and GPU memory writes, ensuring non-blocking execution:

```cpp
ISystem::future_t<size_t> bytesActuallyWritten;
file->read(bytesActuallyWritten, gpuMemory->getMappedPointer(), offsetInFile, 2*1024*1024*1024);
while (!bytesActuallyWritten.ready()) { /* Do other work */ }
```

### 🧩 **Data Transfer Utilities**
Nabla's [Utilities](https://github.com/Devsh-Graphics-Programming/Nabla/blob/master/include/nbl/video/utilities/IUtilities.h) streamlines the process of pushing/pulling arbitrary-sized buffers and images with fixed staging memory to/from the GPU, ensuring seamless data transfers.
 The system automatically handles submission when buffer memory overflows, while [promoting unsupported formats](https://github.com/Devsh-Graphics-Programming/Nabla/tree/dac9855ab4a98d764130e41a69abdc605a91092c/include/nbl/asset/format) during upload to handle color format conversions.
By leveraging device-specific properties, the system respects alignment limits and ensures deterministic behavior. The user only provides initial submission info through [SIntendedSubmitInfo](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/video/utilities/SIntendedSubmitInfo.h#L18), and the utility manages subsequent submissions automatically.

 - Learn more:
   - 🎤 Our Talk at Vulkanised: [Vulkanised 2023: Keeping your staging buffer fixed size! ](https://www.youtube.com/watch?v=x8v656d3pc4)
   - 📚 Our Blog post: [Uploading Textures to GPU - The Good Way](https://erfan-ahmadi.github.io/blog/Nabla/imageupload)


### 🧩 **Virtual File System**  

Nabla provides a [**unified Virtual File System**] ([system::ISystem](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/system/ISystem.h#L19)) that supports **mounting archives and folders** under different virtual paths. This enables access to both external and embedded assets while preserving **original relative paths**.  

For embedding, we provide an alternative to C++23's #embed, which allows embedding files directly into compiled binaries. Instead of relying on compiler support, we use **Python + CMake** to generate what we call **built-in resource archives**—packing files (e.g., images, shaders, `.obj`, `.mtl`, `.dds`) into DLLs as **memory-mapped [system::IFile](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/system/IFile.h#L9) objects** ensuring that dependent assets (e.g., models and their textures) **retain their correct relative paths** even when embedded.  

The embedding process:  
1. **At build time**, Python reads an input path table (generated by CMake).  
2. It serializes files into **constexpr arrays** with metadata (key + timestamps).  
3. The output **C++ source + header** define a **built-in resource library**, linked into Nabla or examples.  

This approach keeps assets self-contained, making file access efficient while maintaining asset dependencies.

### 🧩 **Asset System**
The asset system in Nabla maintains a 1:1 mapping between CPU and GPU representations, where every CPU asset has a direct GPU counterpart.
The system also allows for coordination between loaders—for instance, the OBJ loader can trigger the MTL loader, and the MTL loader in turn invokes image loaders, ensuring smooth asset dependency management.

### 🧩 **Asset Converter (CPU to GPU)**
The Asset Converter transforms CPU objects (`asset::IAsset`) into GPU objects (`video::IBackendObject`) while eliminating duplicates with Merkle Trees. Instead of relying on pointer comparisons, it hashes asset contents to detect and reuse identical GPU objects.

### 🧩 **Unit-Tested BxDFs for Physically Based Rendering**
A statically polymorphic library for defining Bidirectional Scattering Distribution Functions (BxDFs) in HLSL and C++. Each BxDF is rigorously unit-tested in C++ as well as HLSL. This is part of Nabla’s HLSL-C++ compatible library.

Snippet of our [BxDF Unit Test](https://github.com/Devsh-Graphics-Programming/Nabla-Examples-and-Tests/blob/d7f7a87fa08a56a16cd1bcc7d4d9fd48fc8c278c/66_HLSLBxDFTests/main.cpp#L93):

```cpp
TestJacobian<bxdf::reflection::SLambertianBxDF<sample_t, iso_interaction, aniso_interaction, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::reflection::SOrenNayarBxDF<sample_t, iso_interaction, aniso_interaction, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::reflection::SBeckmannBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::reflection::SBeckmannBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, true>::run(initparams, cb);
TestJacobian<bxdf::reflection::SGGXBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::reflection::SGGXBxDF<sample_t, iso_cache, aniso_cache, spectral_t>,true>::run(initparams, cb);

TestJacobian<bxdf::transmission::SLambertianBxDF<sample_t, iso_interaction, aniso_interaction, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::transmission::SSmoothDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::transmission::SSmoothDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t, true>>::run(initparams, cb);
TestJacobian<bxdf::transmission::SBeckmannDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::transmission::SBeckmannDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, true>::run(initparams, cb);
TestJacobian<bxdf::transmission::SGGXDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::transmission::SGGXDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>,true>::run(initparams, cb);
```

### 🔧 **In Progress: Property Pools (GPU Entity Component System)**
*Property Pools* group related properties together in a Structure Of Arrays (SoA) manner, allowing efficient, cache-friendly access to data on the GPU. The system enables transferring properties (Components) between the CPU and GPU, with the `PropertyPoolHandler` managing scattered updates with a special compute shader. Handles are assigned for each object and remain constant as data is added or removed.

### 🧩 **SPIR-V Introspection and Layout Creation**

SPIR-V introspection in Nabla eliminates most of the boilerplate code required to set up descriptor and pipeline layouts, simplifying resource binding to shaders.

### 🧩 **Nabla Extensions**
- [ImGui integration](https://github.com/Devsh-Graphics-Programming/Nabla/tree/master/include/nbl/ext/ImGui) – `MultiDrawIndirect` based and draws in as little as a single drawcall.
- [Fast Fourier Transform Extension](https://github.com/Devsh-Graphics-Programming/Nabla/tree/master/include/nbl/ext/FFT) – for image processing and all kind of frequncy-domain fun.
- [Workgroup Prefix Sum](https://github.com/Devsh-Graphics-Programming/Nabla/tree/master/include/nbl/builtin/hlsl/workgroup) – Efficient parallel prefix sum computation.
- [Blur](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/builtin/hlsl/prefix_sum_blur/blur.hlsl#L3) – Optimized GPU-based image blurring.
- [Counting Sort](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/builtin/hlsl/sort/counting.hlsl) – High-performance, GPU-accelerated sorting algorithm.
- [WIP] Autoexposure – Adaptive brightness adjustment for HDR rendering.
- [WIP] Tonemapping
- [WIP] GPU MPMC Queue – Multi-producer, multi-consumer GPU queue.
- [WIP] OptiX interoperability for ray tracing.
- [WIP] Global Scan – High-speed parallel scanning across large datasets.

### 🚀 **Coming Soon**
- Full CUDA interoperability support.
- Scene Loaders
- GPU-Driven Scene Graph
- Material Compiler 2.0 for efficient scheduling of BxDF graph evaluation

# 🤝 Need Our Expertise?

We specialize in:
- High-performance computing and performance optimization
- Path Tracing and Physically Based Rendering
- CAD Rendering
- Audio Programming and Digital Signal Processing
- Porting and Optimizing legacy Renderers
- Graphics and Compute APIs:
  - Vulkan, D3D12, CUDA, OpenCL, WebGPU, D3D11, OpenGL

Whether you're optimizing your **renderer** or **compute workloads**, looking to **port your legacy renderer**, or integrating complex **visual effects** into your product, our team can help you. As a specialized team, we're constantly learning, evolving, and discussing matters with each other. [Each member](#join-our-team) brings unique insights to the table, ensuring we approach every project from multiple angles to achieve the best possible solution.

Our primary language is **C++20**, but we also work with **C#**, **Java**, **Python**, and other related technologies.

If you're already here reading this, We want to hear from you and learn more about what you're building.

**Contact us** at **newclients@devsh.eu**.

The members of **Devsh Graphics Programming Sp. z O.O.** (Company Registration (KRS) #: 0000764661) are available (individually or collectively) for contracts on projects of various scopes and timescales.

---

# Join our team

[TODO]: also link to achievements, personal blogs, websites, linkedin and presentations of each member
