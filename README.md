# Nabla

test

<div align="center">
  <br/>
  <a href="https://github.com/Devsh-Graphics-Programming/Nabla/blob/readme/nabla-glow.svg">
    <img alt="Click to see the source" height="200" src="nabla-glow.svg" width="200" />
  </a>
  <br/>
</div>

< TODO: short desc >

# Table of Contents

< TODO >

# Showcase

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean eu odio gravida, tristique quam quis, dignissim purus. Sed sed neque facilisis, venenatis odio in, dignissim risus. Nulla facilisi. Aliquam dictum volutpat ligula. Quisque vehicula condimentum bibendum. Morbi posuere, libero ac porttitor molestie, sem enim molestie sapien, at consectetur metus lacus nec justo. Sed sollicitudin nisl ut tellus posuere pharetra. Phasellus in rutrum elit. Nunc dui dui, ultricies eu nunc in, dictum gravida eros. Integer fermentum in turpis non ultricies. Cras sit amet sagittis sapien. Integer dignissim mauris ac magna dapibus, non ultrices risus rhoncus. Sed gravida hendrerit mattis. Pellentesque a congue massa. Nullam in cursus libero. Ut ac tristique mauris.

TODO aspect ratio + images alignment + more more images

<center>
  <table style="width: 100%; border-collapse: collapse; vertical-align:top;">
    <!-- row 1 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/a14ba3d6-338b-4814-b67a-1d680766b5b6" alt="Ray Tracing" style="width:100%; height:auto;">
          <img src="https://github.com/user-attachments/assets/241fdeaf-92c4-4f6e-9a80-73307b4948c6" alt="Ray Tracing" style="width:100%; height:auto;">
        <div align="center">
          <a href="TODO" target="_blank">Ray Tracing</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/07f71a81-1f9f-4874-99ab-ec6b9ce6c598" alt="Emulated shaderFloat64" style="width:100%; height:auto;">
        <div align="center">
          <a href="TODO" target="_blank">Emulated shaderFloat64</a>
        </div>
      </td>
    </tr>
    <!-- row 2 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:bottom; vertical-align: top; valign:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/99831ff2-61af-4c08-9c44-6fd0d04878cb" alt="MSDF Hatches" style="width:100%; height:auto; vertical-align:top; align:top;">
          <img src="https://github.com/user-attachments/assets/095764a5-a07c-499b-a1fb-d1fcd98102f9" alt="MSDF Hatches 2" style="width:100%; height:auto; vertical-align:top; align:top;">
        <div align="center">
          <a href="TODO" target="_blank">MSDF Hatches</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/7941f9f0-876e-4cd8-a6e5-3c403e339c59" alt="TODODOO" style="width:100%; height:auto;">
          <img src="https://github.com/user-attachments/assets/89401139-5f06-4aaf-a081-ed540976660a" alt="TODODOO 2" style="width:100%; height:auto;">
          <img src="https://github.com/user-attachments/assets/d2d56b1e-8a21-4bcd-aa14-8e3e86ec22ba" alt="TODODOO 3" style="width:100%; height:auto;">
        <div align="center">
           <a href="TODO" target="_blank">TODO</a>
        </div>
      </td>
    </tr>
    <!-- row 3 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:bottom; vertical-align: top; valign:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/c399f07f-50ec-4fcd-8914-0433adcd6a35" alt="SDF function manipulator" style="width:100%; height:auto; vertical-align:top; align:top;">
        <div align="center">
          <a href="TODO" target="_blank">SDF function manipulator</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/b7705a3a-ddba-466e-95f0-125458f00349" alt="Fluid 3D" style="width:100%; height:auto;">
        <div align="center">
           <a href="TODO" target="_blank">Fluid 3D</a>
        </div>
      </td>
    </tr>
    <!-- row 4 -->
    <tr>
      <td valign="top"; style="width:50%; text-align:bottom; vertical-align: top; valign:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/124e9de1-5e59-444e-8c14-b536537cda9e" alt="SDF function manipulator" style="width:100%; height:auto; vertical-align:top; align:top;">
        <div align="center">
          <a href="TODO" target="_blank">Volume Reconstuction from Point Clouds</a>
        </div>
      </td>
      <td valign="top"; style="width:50%; text-align:center; vertical-align:top; padding:2%;">
          <img src="https://github.com/user-attachments/assets/86452841-556b-43ed-ad95-ef45452b51d5" alt="ImGUI render backend and extensions" style="width:100%; height:auto;">
        <div align="center">
           <a href="TODO" target="_blank">ImGUI render backend & extensions</a>
        </div>
      </td>
    </tr>
  </table>
</center>

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean eu odio gravida, tristique quam quis, dignissim purus. Sed sed neque facilisis, venenatis odio in, dignissim risus. Nulla facilisi. Aliquam dictum volutpat ligula. Quisque vehicula condimentum bibendum. Morbi posuere, libero ac porttitor molestie, sem enim molestie sapien, at consectetur metus lacus nec justo. Sed sollicitudin nisl ut tellus posuere pharetra. Phasellus in rutrum elit. Nunc dui dui, ultricies eu nunc in, dictum gravida eros. Integer fermentum in turpis non ultricies. Cras sit amet sagittis sapien. Integer dignissim mauris ac magna dapibus, non ultrices risus rhoncus. Sed gravida hendrerit mattis. Pellentesque a congue massa. Nullam in cursus libero. Ut ac tristique mauris.


# Features

### üß© The Nabla Core Profile

Nabla exposes [a curated set of Vulkan extensions and features](https://github.com/Devsh-Graphics-Programming/Nabla/blob/master/src/nbl/video/vulkan/profiles/NablaCore.json) compatible across the GPUs we aim to support on Windows, Linux, (coming soon MacOS, iOS as well as Android)

Vulkan evolves fast‚Äîjust when you think you've figured out [sync](), you realize there's [sync2](). Keeping up with new extensions, best practices, and hardware quirks is exhausting.
Instead of digging through [gpuinfo.org](gpuinfo.org) or [Vulkan specs](), Nabla gives you a well-thought-out set of extensions‚Äîso you can focus on what you want to achieve, not get lost in extreme details.

### üß© Physical Device Selection and Filteration

Nabla allows you to select the best GPU for your compute or graphics workload.

```c++
void filterDevices(core::set<video::IPhysicalDevice*>& physicalDevices)
{
  nbl::video::SPhysicalDeviceFilter deviceFilter = {};
  deviceFilter.minApiVersion = { 1,3,0 };
  deviceFilter.minConformanceVersion = {1,3,0,0};
  deviceFilter.requiredFeatures.rayQuery = true;
  deviceFilter(physicalDevices);
}
```

### üß© SPIR-V and Vulkan as First-Class Citizens

Nabla treats **SPIR-V** and **Vulkan** as the preferred, reference standard‚Äîeverything else is built around them, with all other backends adapting to them.

### üß© Integration of Renderdoc

Built-in support for capturing frames and debugging with [Renderdoc](https://renderdoc.org/).
 This is how one debugs headless or async GPU workloads that are not directly involved in producing a swapchain frame to be captured by Renderdoc.

```c++
const IQueue::SSubmitInfo submitInfo = {
    .waitSemaphores = {},
    .commandBuffers = {&cmdbufInfo,1},
    .signalSemaphores = {&signalInfo,1}
};
m_api->startCapture(); // Start Renderdoc Capture
queue->submit({&submitInfo,1});
m_api->endCapture(); // End Renderdoc Capture
```

### üß© Nabla Event Handler: Seamless GPU-CPU Synchronization

Nabla Event Handler's extensive usage of [Timeline Semaphores](https://www.khronos.org/blog/vulkan-timeline-semaphores) enables CPU Callbacks on GPU conditions.

You can enqueue callbacks that trigger upon submission completion (workload finish), enabling amongst others, async readback of submission side effects, or deallocating an allocation after a workload is finished.

```c++
// This doesn't actually free the memory from the pool, the memory is queued up to be freed only after the `scratchSemaphore` reaches a value a future submit will signal
memory_pool->deallocate(&offset,&size,nextSubmit.getFutureScratchSemaphore());
```

### üß© GPU Object Lifecycle Tracking

Nabla uses [reference counting]() to track the lifecycle of GPU objects. Descriptor sets and command buffers are responsible for maintaining reference counts on the resources (e.g., buffers, textures) they use. The queue itself also tracks command buffers, ensuring that objects remain alive as long as they are pending execution. This system guarantees the correct order of deletion and makes it difficult for GPU objects to go out of scope and be destroyed before the GPU has finished using them.

### üß© HLSL2021 Standard Template Library

- üîÑ Reusable: Unified single-source C++/HLSL libraries eliminate code duplication with reimplementation of STL's `type_traits`, `limits`, `functional`, `tgmath`, etc.

- üêû Shader Logic, CPU-Tested: A subset of HLSL compiles as both C++ and SPIR-V, enabling CPU-side debugging of GPU logic, ensuring correctness in complex tasks like FFT, Prefix Sum, etc. (See our examples: [1. BxDF Unit Test](https://github.com/Devsh-Graphics-Programming/Nabla-Examples-and-Tests/blob/d7f7a87fa08a56a16cd1bcc7d4d9fd48fc8c278c/66_HLSLBxDFTests/app_resources/tests.hlsl#L436), [2. Math Funcs Unit Test](https://github.com/Devsh-Graphics-Programming/Nabla-Examples-and-Tests/blob/fd92730f0f5c8a120782c928309cb10e776c25db/22_CppCompat/main.cpp#L407))

- üîÆ Future-Proof: C++20 concepts in HLSL enable safe and documented polymorphism.

- üß† Insane: Boost Preprocessor and Template Metaprogramming in HLSL!

- üõ†Ô∏è Real-World Problem Solvers: The library offers GPU-optimized solutions for tasks like Prefix Sum, Binary Search, FFT, Global Sort, and even emulated `shaderFloat64` when native GPU support is unavailable!

üé§ Talks from us:
 - [Vulkanised 2024: Beyond SPIR-V: Single Source C++ and Shader Programming](https://www.youtube.com/watch?v=JCJ35dlZJb4)
 - [Vulkanised 2023: HLSL202x like its C++, building an `std::` like Library]()

### üß© Full Embrace of [Buffer Device Address]() and [Descriptor Indexing]()

By utilizing Buffer Device Addresses (BDAs), Nabla enables more direct access to memory through 64-bit GPU virtual addresses. Synergized with Descriptor Indexing, this approach enhances flexibility by enabling more dynamic, scalable resource binding without relying on traditional descriptor sets.

### üß© Minimally Invasive Design

Nabla's minimally invasive and flexible design with api handle acquisitions and multi-window support make it ideal for custom rendering setups and low-level GPU programming without unnecessary constraints such as assuming a main thread or a single window.

This allows simpler porting of legacy OpenGL and DirectX applications.

[TDOO:Insert Diff Image]


### üß© Designed for Interoperation
Nabla is built with interoperation in mind, supporting memory export and import between different compute and graphics APIs.

### üß© TODO: Cancellable Future based Async I/O
```
somewhere here you can add "No Singletons, No Main Thread"

Basically you can have as many instances of every object as you please (VK device), there's no assumption of a main thread or threadwise contexts.

Not thread safe, but thread agnostic, we avoid global state, we pass contexts around explicitly to allow for easy multithreading (e.g. no mutable state in factory classes).

Can also mentioned that we managed to wrap Win32 windowing in a way that lets you use it from multiple threads.
```


### üß© Data Transfer Utilities
Nabla's [Utilities](https://github.com/Devsh-Graphics-Programming/Nabla/blob/master/include/nbl/video/utilities/IUtilities.h) streamlines the process of pushing/pulling arbitrary-sized buffers and images with fixed staging memory to/from the GPU, ensuring seamless data transfers.
 The system automatically handles submission when buffer memory overflows, while [promoting unsupported formats](https://github.com/Devsh-Graphics-Programming/Nabla/tree/dac9855ab4a98d764130e41a69abdc605a91092c/include/nbl/asset/format) during upload to handle color format conversions.
By leveraging device-specific properties, the system respects alignment limits and ensures deterministic behavior. The user only provides initial submission info through [SIntendedSubmitInfo](), and the utility manages subsequent submissions automatically.

 - Learn more:
   - üé§ Our Talk at Vulkanised: [Vulkanised 2023: Keeping your staging buffer fixed size! ](https://www.youtube.com/watch?v=x8v656d3pc4)
   - üìö Our Blog post: [Uploading Textures to GPU - The Good Way](https://erfan-ahmadi.github.io/blog/Nabla/imageupload)


### üß© TODO: Virtual File System (archive mounting, our alternative to #embed, everything is referenced by absolute - path)

### üß© Asset System
The asset system in Nabla maintains a 1:1 mapping between CPU and GPU representations, where every CPU asset has a direct GPU counterpart.
The system also allows for coordination between loaders‚Äîfor instance, the OBJ loader can trigger the MTL loader, and the MTL loader in turn invokes image loaders, ensuring smooth asset dependency management.

### üß© Asset Converter (CPU to GPU)
The Asset Converter transforms CPU objects (`asset::IAsset`) into GPU objects (`video::IBackendObject`) while eliminating duplicates with Merkle Trees. Instead of relying on pointer comparisons, it hashes asset contents to detect and reuse identical GPU objects.

### üß© Unit-Tested BxDFs for Physically Based Rendering
A statically polymorphic library for defining Bidirectional Scattering Distribution Functions (BxDFs) in HLSL and C++. Each BxDF is rigorously unit-tested in C++ as well as HLSL. This is part of Nabla‚Äôs HLSL-C++ compatible library.

Part of our [BxDF Unit Test](https://github.com/Devsh-Graphics-Programming/Nabla-Examples-and-Tests/blob/d7f7a87fa08a56a16cd1bcc7d4d9fd48fc8c278c/66_HLSLBxDFTests/main.cpp#L93):

```cpp
TestJacobian<bxdf::reflection::SLambertianBxDF<sample_t, iso_interaction, aniso_interaction, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::reflection::SOrenNayarBxDF<sample_t, iso_interaction, aniso_interaction, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::reflection::SBeckmannBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::reflection::SBeckmannBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, true>::run(initparams, cb);
TestJacobian<bxdf::reflection::SGGXBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::reflection::SGGXBxDF<sample_t, iso_cache, aniso_cache, spectral_t>,true>::run(initparams, cb);

TestJacobian<bxdf::transmission::SLambertianBxDF<sample_t, iso_interaction, aniso_interaction, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::transmission::SSmoothDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>>::run(initparams, cb);
TestJacobian<bxdf::transmission::SSmoothDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t, true>>::run(initparams, cb);
TestJacobian<bxdf::transmission::SBeckmannDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::transmission::SBeckmannDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, true>::run(initparams, cb);
TestJacobian<bxdf::transmission::SGGXDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>, false>::run(initparams, cb);
TestJacobian<bxdf::transmission::SGGXDielectricBxDF<sample_t, iso_cache, aniso_cache, spectral_t>,true>::run(initparams, cb);
```

### üîß In Progress: Property Pools (GPU Entity Component System)
*Property Pools* group related properties together in a Structure Of Arrays (SoA) manner, allowing efficient, cache-friendly access to data on the GPU. The system enables transferring properties (Components) between the CPU and GPU, with the `PropertyPoolHandler` managing scattered updates with a special compute shader. Handles are assigned for each object and remain constant as data is added or removed.

### üß© SPIR-V Introspection and Layout Creation

SPIR-V introspection in Nabla eliminates most of the boilerplate code required to set up descriptor and pipeline layouts, simplifying resource binding to shaders.

### üß© Nabla Extensions
- [ImGui integration](https://github.com/Devsh-Graphics-Programming/Nabla/tree/master/include/nbl/ext/ImGui) ‚Äì `MultiDrawIndirect` based and draws in as little as a single drawcall.
- [Fast Fourier Transform Extension](https://github.com/Devsh-Graphics-Programming/Nabla/tree/master/include/nbl/ext/FFT) ‚Äì for image processing and all kind of frequncy-domain fun.
- [Workgroup Prefix Sum](https://github.com/Devsh-Graphics-Programming/Nabla/tree/master/include/nbl/builtin/hlsl/workgroup) ‚Äì Efficient parallel prefix sum computation.
- [Blur](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/builtin/hlsl/prefix_sum_blur/blur.hlsl#L3) ‚Äì Optimized GPU-based image blurring.
- [Counting Sort](https://github.com/Devsh-Graphics-Programming/Nabla/blob/ff07cd71c4e21bc51fa416ccd151b2e92efea028/include/nbl/builtin/hlsl/sort/counting.hlsl) ‚Äì High-performance, GPU-accelerated sorting algorithm.
- [WIP] Autoexposure ‚Äì Adaptive brightness adjustment for HDR rendering.
- [WIP] Tonemapping
- [WIP] GPU MPMC Queue ‚Äì Multi-producer, multi-consumer GPU queue.
- [WIP] OptiX interoperability for ray tracing.
- [WIP] Global Scan ‚Äì High-speed parallel scanning across large datasets.

### üöÄ Coming Soon
- Full CUDA interoperability support.
- Scene Loaders
- GPU-Driven Scene Graph
- Material Compiler 2.0 for efficient scheduling of BxDF graph evaluation

# FAQ

< FAQ >

# Get expert

< TODO >

# Join our team

< TODO >
